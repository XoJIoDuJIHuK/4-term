# Глава 12
# Перечисления, автоупаковка, статический импорт и аннотации
Основные навыки и понятия
* Представление о перечислениях
* Применение свойств перечислений, основанных на классах
* Применение методов values() и valueof() к перечислениям
* Создание перечислений с конструкторами, переменными экземпляра и методами
* Применение методов ordinal() и compareTo(), наследуемых перечислениями от класса Enum
* Использование оболочек типов Java
* Основные положения об автоупаковке и автораспаковке
* Применение автоупаковки в методах
* Употребление автоупаковки в выражениях
* Применение статического импорта
* Основные положения об аннотациях

В этой главе рассматриваются четыре относительно новые языковые средства Java: перечислинения, автоупаковка, статический импорт и аннотации. И хотя ни одно из них не вошло в первоначальное описание Java, каждое из них расширяет возможности и область применения этого языка программирования. Так, перечисления и автоупаковка удовлетворяют давно назревшим потребностям, статический импорт упрощает применение статических членов класса, тогда как аннотации расширяют виды информации, которую можно встраивать в исходный файл. А сообща все эти средства обеспечивают более совершенное решение насущных задач программирования. В этой главе рассматриваются также оболочки типов Java.

## Перечисления
Несмотря на то что перечисления применяются во многих языках программирования, в первоначальном описании Java они не поддерживалась. Это, в частности, объясняется тем, что перечисление является скорее удобным, чем обязательным языковым средством. Но со временем программирующие на Java все чаще стали ощущать потребность в перечислениях, потому что с их помощью они могли реализовать структурно изящные решения многих задач программирования. И эта потребность была учтена в версии JDK 5, начиная с которой перечисления внедрены в Java.

В простейшем виде перечисление представляет собой список именованных констант, определяющих новый тип данных. Объект перечислимого типа может принимать лишь значения, содержащиеся в списке. Таким образом, перечисления предоставляют возможность точно определить новый тип данных, имеющий строго фиксированный ряд допустимых значений.

В повседневной жизни перечисления встречаются довольно часто. Например, к ним можно отнести ряд монет, имеющих хождение в стране. А месяцы года и дни недели перечисляются по названиям.

С точки зрения программирования перечисления оказываются удобными в тех случаях, когда требуется определить ряд значений, обозначающих совокупность элементов. Например, с помощью перечисления можно представить набор кодов состояния (успешное завершение, ошибка, необходимость повторной попытки). Конечно, такие значения можно определить и с помощью констант типа final, но перечисления обеспечивают более структурированный подход к решению подобной задачи.

## Основные положения о перечислениях
Для создания перечисления служит ключевое слово enum. Ниже приведен пример простого перечисления разных видов транспортных средств.
```
// Перечисление видов транспортных средств,
enum Transport {
    CAR, TRUCK, AIRPLANE, TRAIN, BOAT
}
```
Идентификаторы CAR, TRUCK и так далее называются константами перечислимого типа. Каждый из них автоматически неявно объявляется как открытый (public), статический (static) член перечисления Transport. Тип этих констант соответствует типу перечисления (в данном случае — Transport). В терминологии Java подобные константы называются самотипизированными (приставка “само” означает, что в качестве типа константы принимается тип перечисления).

Определив перечисление, можно создать переменную данного типа. Но, несмотря на то, что перечисление определяется как тип класса, получить экземпляр объекта типа enum с помощью оператора new нельзя. Переменная перечислимого типа создается подобно переменной простого типа. Например, для объявления переменной tp упомянутого выше перечислимого типа Transport служит следующее выражение:
```
Transport tp;
```
Переменная tp относится к типу Transport, и поэтому ей можно присваивать только те значения, которые определены в данном перечислении. Например, в следующей строке кода переменной tp присваивается значение AIRPLANE:
```
tp = Transport.AIRPLANE;
```
Обратите внимание на то, что идентификатор AIRPLANE полностью определяется как относящийся к типу Transport.

Для проверки равенства констант перечислимого типа служит оператор сравнения =. Например, в приведенной ниже строке кода содержимое переменной tp сравнивается с константой TRAIN,
```
if(tp == Transport.TRAIN) // ...
```
Перечислимые значения можно также использовать в операторе switch. Очевидно, что в ветвях case этого оператора могут присутствовать только константы того же самого перечислимого типа, что и в выражении switch. Например, следующий фрагмент кода составлен правильно:
```
// Применение перечисления для управления оператором switch,
switch(tp) {
case CAR:
    // ...
case TRUCK:
    // ...
```
Как видите, в ветвях case используются константы без полного определения имени типа. Например, вместо Transport. TRUCK указано просто TRUCK. Это допустимо потому, что перечислимый тип в выражении switch неявно определяет тип констант в ветвях case. Более того, если попытаться указать тип константы явно, при компиляции возникнет ошибка.

При отображении константы перечислимого типа, например, с помощью метода println(), выводится ее имя. Так, в результате выполнения следующего оператора отобразится имя BOAT:
```
System.out.println(Transport.BOAT);
```
Ниже приведен пример программы, демонстрирующий все особенности применения перечисления Transport.
```
// Особенности применения перечисления Transport.
// Объявление перечисления.
enum Transport {
CAR, TRUCK, AIRPLANE, TRAIN, BOAT
}
class EnumDemo {
    public static void main(String args[])
    {
        // Объявление ссылки на перечисление Transport.
        Transport tp;

        // Присваивание переменной tp константы AIRPLANE.
        tp = Transport.AIRPLANE;

        // вывести перечислимое значение
        System.out.println("Value of tp: " + tp) ;
        System.out.println();

        tp = Transport.TRAIN;

        // Проверка равенства двух объектов типа Transport.
        if(tp == Transport.TRAIN) // сравнить два перечислимых значения
            System.out.println("tp contains TRAIN.\n");

        // Использование перечисления для управления оператором switch.
        switch(tp) {
        case CAR:
            System.out.println("A car carries people.");
            break;
        case TRUCK:
            System.out.println("A truck carries freight.");
            break;
        case AIRPLANE:
            System.out.println("An airplane flies.");
            break;
        case TRAIN:
            System.out.println("A train runs on rails.");
            break;
        case BOAT:
            System.put.println("A boat sails on water.");
            break;
        }
    }
}
```
Результат выполнения данной программы выглядит следующим образом:
```
Value of tp: AIRPLANE

tp contains TRAIN.

A train runs on rails.
```
Прежде чем переходить к рассмотрению следующей темы, необходимо сделать одно замечание. Имена констант в перечислении Transport указываются прописными буквами (например, одна из них называется CAR, а не саг). Но это требование не является обязательным. Не существует никаких ограничений на использование регистра символов в именах констант перечислимого типа. Но поскольку константы перечислимого типа, как правило, предназначены для замены переменных, объявленных как final, имена которых по традиции обозначаются прописными буквами, то и имена констант перечислимого типа, как правило, обозначаются прописными буквами. И хотя на этот счет имеются разные точки зрения, в примерах программ, представленных в этой книге, для констант перечислимого типа будут выбираться имена, обозначаемые прописными буквами.

### Перечисления в Java относятся к типам классов
Приведенные выше примеры демонстрируют создание и использование перечислений, но они не дают полного представления обо всех их возможностях. В отличие от других языков программирования перечисления в Java реализованы как типы классов. И хотя создать экземпляр объекта типа enum с помощью оператора new нельзя, во всем остальном перечисления ничем не отличаются от классов. Такой способ реализации перечислений наделяет их богатыми возможностями, принципиально недостижимыми в других языках. Это, в частности, позволяет определять конструкторы перечислений, добавлять в них переменные экземпляра, методы и даже создавать перечисления, реализующие интерфейсы.

## Методы values() и vaJueOf()
У всех перечислений имеются два предопределенных метода: values() и valueOf().

Ниже приведены общие формы их объявления.
```
public static перечислимый_тип[] values()
public static перечислимый_тип valueOf(String str)
```
Метод values() возвращает массив, содержащий константы перечислимого типа, а метод valueOf() — константу того же типа, значение которой соответствует символьной строке str, передаваемой этому методу в качестве параметра. В обоих чаях перечислимый_тип обозначает тип используемого перечисления. Так, если воспользоваться рассмотренным выше перечислением Transport, то при вызове метода Transport .valueOf ("TRAIN") будет возвращено значение TRAIN типа Transport. Ниже приведен пример программы, демонстрирующий применение методов values() и valueOf().
```
// Применение встроенных в перечисление методов.
// Перечисление разных видов транспорта,
enum Transport {
CAR, TRUCK, AIRPLANE, TRAIN, BOAT
}
class EnumDemo2 {
    public static void main(String args[])
    {
        Transport tp;

        System.out.println("Here are all Transport constants");

        // воспользоваться методом values()
        // Получение массива констант типа Transport.
        Transport allTransports[] = Transport.values();
        for(Transport t : allTransports)
            System.out.println(t);

        System.out.println();

        // воспользоваться методом valueOf()
        // Получение константы под названием AIRPLANE.
        tp = Transport.valueOf("AIRPLANE");
        System.out.println("tp contains " + tp);
    }
}
```
Выполнение этой программы дает следующий результат:
```
Here are all Transport constants
CAR
TRUCK
AIRPLANE
TRAIN
BOAT
tp contains AIRPLANE
```
Обратите внимание на то, что в данном примере программы для перебора массива констант, полученного с помощью метода values(), используется вариант for-each цикла for. Ради большей наглядности данного примера в его коде создается переменная allTransports, которой присваивается ссылка на массив констант перечислимого типа. Но делать это совсем не обязательно, а цикл for можно написать так, как показано ниже. В этом случае необходимость в дополнительной переменной allTransports отпадает.
```
for(Transport t : Transport.values())
    System.out.println(t);
```
Обратите также внимание на то, что значение, соответствующее имени AIRPLANE, было получено в результате вызова метода valueOf():
```
tp = Transport.valueOf("AIRPLANE");
```
Как пояснялось выше, метод valueOf() возвращает значение перечислимого типа, связанное с именем константы, которое передается в виде символьной строки при вызове этого метода.

## Конструкторы, методы, переменные экземпляра и перечисления
Следует иметь в виду, что каждая константа перечислимого типа является объектом этого же типа, а следовательно, в перечислении можно определить конструкторы, ввести методы и объявить переменные экземпляра. Если определить для объекта перечислимого типа enum конструктор, он будет вызываться при создании каждой константы этого типа. А каждая константа перечислимого типа позволяет вызвать любой метод, определенный в перечислении. И у каждой константы перечислимого типа имеется собственная копия любой переменной экземпляра, определенной в перечислении. Ниже приведен пример с новой версией перечисления Transport, демонстрирующий применение конструктора, переменной экземпляра и метода. Благодаря им появляется возможность определить обычную скорость передвижения различных транспортных средств.
```
// Применение конструктора, переменной экземпляра и
// метода в перечислении,
enum Transport {
    // Обратите внимание на инициализирующие значения констант.
    CAR(65), TRUCK(55), AIRPLANE(600), TRAIN(70), BOAT(22);

    // Объявление переменной экземпляра.
    private int speed; // обычная скорость каждого транспортного средства

    // Объявление конструктора.
    Transport(int s) { speed = s; }

    // Определение метода.
    int getSpeed() { return speed; }
}

class EnumDemo3 {
    public static void main(String args[])
    {
        Transport tp;

        // отобразить скорость самолета
        // Скорость определяется с помощью метода getSpeed().
        System.out.println("Typical speed for an airplane is " +
                           Transport.AIRPLANE.getSpeed() +
                           " miles per hour.\n");

        // отобразить все виды транспорта и скорости их передвижения
        System.out.println("All Transport speeds: ");
        for(Transport t : Transport.values())
            System.out.println(t + " typical speed is " +
                               t.getSpeedO +
                               " miles per hour.");
    }
}
```
Выполнение этой программы дает следующий результат:
```
Typical speed for an airplane is 600 miles per hour.

All Transport speeds:
CAR typical speed is 65 miles per hour.
TRUCK typical speed is 55 miles per hour.
AIRPLANE typical speed is 600 miles per hour.
TRAIN typical speed is 70 miles per hour.
BOAT typical speed is 22 miles per hour.
```
В эту версию перечисления Transport внесен ряд дополнений. Во-первых, появилась переменная экземпляра speed, используемая для хранения скорости передвижения каждого вида транспортных средств. Во-вторых, в перечисление Transport добавлен конструктор, которому передается значение скорости. И в-третьих, в это перечисление добавлен метод getSpeedO , возвращающий значение переменной speed, т.е. скорость передвижения конкретного транспортного средства.

Когда переменная tp объявляется в методе main(), конструктор Transport() автоматически вызывается для каждой указанной константы. Аргументы, передаваемые конструктору, указываются в скобках после имени константы, как показано ниже.
```
CAR(65), TRUCK(55), AIRPLANE(600), TRAIN(70), BOAT(22);
```
Числовые значения, передаваемые конструктору Transport() в качестве параметра s, присваиваются переменной speed. Обратите также внимание на то, что список констант перечислимого типа завершается точкой с запятой. Последней в этом списке указана константа BOAT. Точка с запятой требуется в том случае, если, помимо констант, в перечислении присутствуют и другие члены.

У каждой константы перечислимого типа имеется собственная копия переменной speed, что дает возможность выяснить скорость передвижения конкретного транспортного средства, вызвав метод getSpeed(). Например, в методе main() скорость самолета определяется при следующем вызове:
```
Transport.AIRPLANE.getSpeed()
```
Скорость каждого транспортного средства определяется путем перебора констант перечислимого типа в цикле for. А поскольку у каждой такой константы имеется своя копия переменной speed, то значения скорости, связанные с разными константами, отличаются друг от друга. Это довольно эффективный принцип организации перечислений, но он возможен только в том случае, если перечисления реализованы в виде классов, как это сделано в Java.

В предыдущем примере использовался только один конструктор, но перечисления, как и обычные классы, допускают любое число конструкторов.

### Два важных ограничения
На перечисления накладываются два ограничения. Во-первых, перечисление не может быть подклассом другого класса. И во-вторых, перечисление не может выступать в роли суперкласса. Иными словами, перечислимый тип enum нельзя расширять. Если бы это было не так, перечисления действовали бы как обычные классы. Основной же особенностью перечислений является создание констант в виде объектов того класса, в котором они были объявлены.

## Наследование перечислений от класса Enum
Несмотря на то что при объявлении перечислимого типа enum нельзя указывать суперкласс, все перечисления автоматически наследуют переменные и методы от класса java.lang.Enum. В этом классе определен ряд методов, доступных для использования всеми перечислениями. И хотя большинство этих методов используются редко, тем не менее два из них иногда применяются в программах на Java. Это методы ordinal() и compareTo().

Метод ordinal() принимает значение, обозначающее положение константы перечислимого типа в списке. Это значение принято называть порядковым. Ниже приведена общая форма объявления метода ordinal().
```
final int ordinal()
```
Этот метод возвращает порядковое значение вызывающей константы. Отсчет порядковых значений начинается с нуля. Следовательно, в упоминавшемся выше перечислении Transport порядковое значение константы CAR равно нулю, константы TRUCK — 1, константы AIRPLANE — 2 И Т.Д.

Для сравнения порядковых значений двух констант в одном и том же перечислении можно воспользоваться методом compareTo(). Ниже приведена общая форма объявления этого метода.
```
final int compareTo(перечислимый_тип е)
```
Здесь в качестве параметра е задается константа, сравниваемая с вызывающей константой, а перед ней указывается перечислимый_тип, к которому эта константа относится. Следует иметь в виду, что вызывающая константа и константа е должны относиться к одному и тому же перечислимому типу. Так, если порядковое значение вызывающей константы оказывается меньше, чем у константы е, метод compareTo() возвращает отрицательное значение. Если же их порядковые значения совпадают, вращается нулевое значение. И наконец, если порядковое значение вызывающей константы больше, чем у константы е, метод возвращает положительное значение.

Ниже приведен пример программы, демонстрирующий применение методов ordinal() иcompareTo().
```
// Применение методов ordinal() и compareTo().

// Перечисление разных видов транспорта,
enum Transport {
    CAR, TRUCK, AIRPLANE, TRAIN, BOAT
}

class EnumDemo4 {
    public static void main(String args[])
    {
        Transport tp, tp2, tp3;

        // получить все порядковые значения с помощью метода ordinal()
        System.out.println("Here are all Transport constants" +
                           " and their ordinal values: ");

        for(Transport t : Transport.values())
            // Получение порядковых значений констант.
            System.out.println(t + " " + t.ordinal());

        tp = Transport.AIRPLANE;
        tp2 = Transport.TRAIN;
        tp3 = Transport.AIRPLANE;

        System.out.println();

        // продемонстрировать применение метода сошрагеТо()
        // Сравнение порядковых значений констант.
        if(tp.compareTo(tp2) < 0)
            System.out.println(tp + " comes before " + tp2) ;

        if(tp.compareTo(tp2) > 0)
            System.out.println(tp2 + " comes before " + tp);

        if(tp.compareTo(tp3) == 0)
            System.out.println(tp + " equals " + tp3);
    }
}
```
Результат выполнения данной программы выглядит следующим образом:
Here are all Transport constants and their ordinal values:
```
CAR 0
TRUCK 1
AIRPLANE 2
TRAIN 3
BOAT 4

AIRPLANE comes before TRAIN
AIRPLANE equals AIRPLANE
```

**Пример для опробования 12.1.**
Автоматизированный светофор

Перечисления оказываются полезными в тех случаях, когда в программе требуется набор констант, конкретные значения которых не важны, — достаточно, чтобы они отличались друг от друга. Необходимость в подобных наборах констант часто возникает при написании программ. Одним из характерных тому примеров служит поддержка устройств, которые могут находиться в нескольких фиксированных состояниях.Допустим, требуется программа, управляющая светофором, переключающимся в три состояния, обозначаемые зеленым, желтым и красным цветом. Необходимо также, чтобы программа могла определять текущий цвет и устанавливать светофор в исходное состояние. Таким образом, нужно как-либо представлять три возможных состояния светофора. И хотя для этой цели вполне допустимо применять целочисленные значения, например, 1, 2 и 3 или символьные строки "red" (красный), "green" (зеленый) и "yellow" (желтый), вместо них лучше всего воспользоваться перечислением. С помощью перечисления можно написать более эффективный и структурированный код, чем тот, в котором применяются символьные строки и целочисленные значения.

В этом проекте предстоит сымитировать автоматизированный светофор. А по ходу дела будет продемонстрировано применение не только перечислений, но и многопоточной обработки и синхронизации потоков.

Последовательность действий
1. Создайте файл TrafficLightDemo.java.
2. Начните с создания перечисления TrafficLightColor, которое представляет три состояния светофора.
    ```
    // Перечисление, представляющее состояния светофора,
    enum TrafficLightColor {
        RED, GREEN, YELLOW
    }
    ```
    Каждая из констант в этом перечислении соответствует одному цвету светофора.
3. Далее начните определение класса Traf f icLightSimulator так, как показано ниже. Этот класс инкапсулирует имитацию светофора.
    ```
    // Имитация автоматизированного светофора,
    class TrafficLightSimulator implements Runnable {
    private Thread thrd; // Поток для имитации светофора
    private TrafficLightColor tic; // Текущий цвет светофора
    boolean stop = false; // Остановка имитации, если истинно
    boolean changed = false; // Переключение.светофора, если истинно

    TrafficLightSimulator(TrafficLightColor init) {
        tic = init;
        thrd = new Thread(this);
        thrd.start();
    }

    TrafficLightSimulator() {
        tic = TrafficLightColor.RED;
        thrd = new Thread(this);
        thrd.start();
    }
    ```
    Как видите, класс TrafficLightSimulator реализует интерфейс Runnable. Благодаря этому каждое состояние светофора и его цвет регулируется в отдельном потоке. Как следует из приведенного выше исходного кода, в классе TrafficLightSimulator определены два конструктора. Первый из них служит для указания исходного цвета светофора. А второй принимает в качестве исходного красный цвет. Оба конструктора запускают на исполнение новый поток.

    А теперь рассмотрим переменные экземпляра. Ссылка на поток, регулирующий состояние и цвет светофора, хранится в переменной thrd. А сведения о текущем цвете хранятся в переменной tic. Переменная stop служит для остановки имитации автоматизированного светофора. Первоначально она принимает логическое значение false. Имитация светофора будет действовать до тех пор, пока эта переменная не примет логическое значение true. И наконец, переменная changed принимает логическое значение true при переключении светофора, когда его цвет меняется.
4. Введите приведенный ниже метод run(), начинающий имитацию автоматизированного светофора.
    ```
    // Запуск имитации автоматизированного светофора,
    public void run()  {
        while(!stop) {

            try {
                switch(tic) {
                case GREEN:
                    Thread.sleep(10000); // Зеленый на 10 секунд
                    break;
                case YELLOW:
                    Thread.sleep(2000); // Желтый на 2 секунды
                    break;
                case RED:
                    Thread.sleep(12000); // Красный на 12 секунд
                    break;
                }
            } catch(InterruptedException exc) {
                System.out.println(exc);
            }
            changeColor();
        }
    }
    ```
    Этот метод переключает цвета светофора по очереди. Сначала выполнение потока приостанавливается на заданный промежуток времени, который выбирается в зависимости от конкретного цвета светофора. Затем вызывается метод changeColor(), переключающий цвет светофора.
5. Введите приведенный ниже метод changeColor(), переключающий цвет светофора.
    ```
    // Переключение цвета светофора,
    synchronized void changeColor() {

        switch(tic) {
        case RED:
            tic = TrafficLightColor.GREEN;
            break;
        case YELLOW:
            tic = TrafficLightColor.RED;
            break;
        case GREEN:
            tic = TrafficLightColor.YELLOW;
        }

        changed = true;
        notify(); // уведомить о переключении цвета светофора
    }
    ```
6. В операторе switch проверяются сведения о цвете светофора, хранящиеся в переменной tic, после чего этой переменной присваивается другой цвет. Обратите внимание на то, что этот метод синхронизирован. Это необходимо потому, что он вызывает метод notify(), уведомляющий о смене цвета. (Напомним, что обратиться к методу notify() можно только из синхронизированного контекста.)
7. Далее введите метод wait For Change(), ожидающий переключения цвета светофора.
    ```
    // Ожидание переключения цвета светофора,
    synchronized void waitForChange() {
        try {
            while(!changed)
                wait(); // ожидать переключения цвета светофора
            changed = false;
        } catch(InterruptedException exc) {
            System.out.println(exc);
        }
    }
    ```
    Действие этого метода ограничивается вызовом метода wait(). Возврат из него не произойдет до тех пор, пока в методе changeColor() не будет вызван метод notify(). Следовательно, метод waitForChange() не завершится до переключения цвета светофора.
8. И наконец, введите метод getColor(), возвращающий текущий цвет светофора, а вслед за ним — метод cancel(), останавливающий имитацию светофора, присваивая переменной stop логическое значение true. Ниже приведен исходный код обоих методов.
    ```
    // Возврат текущего цвета.
    TrafficLightColor getColor() {
        return tic;
    }

    // Прекращение имитации светофора.
    void cancel() {
        stop = true;
    }
    ```
9. Ниже приведен весь исходный код программы, имитирующей автоматизированный светофор с помощью перечисления.
    ```
    // Пример для опробования 12.1.

    // Имитация автоматизированного светофора с помощью
    // перечисления, описывающего переключаемые цвета светофора.

    // Перечисление, представляющее состояния светофора,
    enum TrafficLightColor {
        RED, GREEN, YELLOW
    }

    // Имитация автоматизированного светофора,
    class TrafficLightSimulator implements Runnable {
        private Thread thrd; // Поток для имитации светофора
        private TrafficLightColor tic; // Текущий цвет светофора
        boolean stop = false; // Остановка имитации, если истинно
        boolean changed = false; // Переключение светофора, если истинно

        TrafficLightSimulator(TrafficLightColor init) {
            tic = init;

            thrd = new Thread(this);
            thrd.start();
        }

        TrafficLightSimulator() {
            tic = TrafficLightColor.RED;

            thrd = new Thread(this);
            thrd.start();
        }

        // Запуск имитации автоматизированного светофора,
        public void run() {
            while(!stop) {

                try {
                    switch(tic) {
                    case GREEN:
                        Thread.sleep(10000); // Зеленый на 10 секунд
                        break;
                    case YELLOW:
                        Thread.sleep(2000); // Желтый на 2 секунды
                        break;
                    case RED:
                        Thread.sleep(12000); // Красный на 12 секунд
                        break;
                    }
                } catch(InterruptedException exc) {
                    System.out.println(exc);
                }
                changeColor() ;
            }
        }

        // Переключение цвета светофора,
        synchronized void changeColor() {

            switch(tic) {
                case RED:
                    tic = TrafficLightColor.GREEN;
                    break;
                case YELLOW:
                    tic = TrafficLightColor.RED;
                    break;
                case GREEN:
                    tic = TrafficLightColor.YELLOW;
            }

            changed = true;
            notify(); // уведомить о переключении цвета светофора
        }

        // Ожидание переключения цвета светофора.
        synchronized void waitForChange() {
            try {
                while(!changed)
                    wait(); // ожидать переключения цвета светофора
                changed = false;
            } catch(InterruptedException exc) {
                System.out.println(exc);
            }
        }

        // Возврат текущего цвета.
        TrafficLightColor getColor() {
            return tic;
        }

        // Прекращение имитации светофора,
        void cancel() {
            stop = true;
        }
    }

    class TrafficLightDemo {
        public static void main(String args[]) {
            TrafficLightSimulator tl =
                new TrafficLightSimulator(TrafficLightColor.GREEN);

            for (int i=0; i < 9; i++) {
                System.out.println(tl.getColor());
                tl.waitForChange();
            }
            tl.cancel();
        }
    }
    ```
    При выполнении этой программы на экран выводится приведенный ниже результат. Как видите, цвета светофора переключаются в требуемой очередности: зеленый, желтый, красный.
    ```
    GREEN
    YELLOW
    RED
    GREEN
    YELLOW
    RED
    GREEN
    YELLOW
    RED
    ```
    Обратите внимание на то, что перечисление позволяет сделать исходный код данной программы более структурированным. Светофор может находиться в одном из трех состояний, и для этой цели в перечислении предусмотрены только три константы. Благодаря этому исключается случайное переключение имитируемого светофора в недопустимое состояние.
10. Используя тот факт, что перечисления реализуются в виде классов, можете усовершенствовать рассмотренную здесь программу. Соответствующее задание будет предложено в упражнении для самопроверки по материалу этой главы в самом ее конце.

## Автоупаковка
В версии JDK 5 были реализованы два очень важных языковых средства, недостаток которых долгое время ощущали программирующие на Java. Речь идет об автоупаковке и автораспаковке, существенно упрощающих и ускоряющих создание кода, в котором приходится преобразовывать простые типы данных в объекты, и наоборот. А поскольку такие потребности возникают в программах довольно часто, то появление автоупаковки и автораспаковки положительно сказалось на работе практически всех программирующих на Java. Как будет показано в главе 13, автоупаковка и автораспаковка способствовали практическому применению обобщений — еще одного языкового средства, реализованного в Java.

Автоупаковка и автораспаковка непосредственно связаны с оболочками типов и способами внедрения и извлечения значений из экземпляров оболочек. Поэтому рассмотрим сначала оболочки типов и способы упаковки и распаковки Значений вручную.

### Оболочки типов
Как вам должно быть уже известно, в Java предусмотрены простые типы данных, в том числе int и double. Простые типы позволяют добиться более высокой эффективности вычислений по сравнению с объектами. Но простые типы не являются частью иерархии объектов и не наследуют свойства и методы класса Object.

Несмотря на высокую эффективность простых типов, возникают такие ситуации, когда для представления данных желательно использовать объекты. Например, переменную простого типа нельзя передать методу по ссылке. Кроме того, многие стандартные структуры данных, реализованные в Java, предполагают работу с объектами, и поэтому в них нельзя хранить данные простых типов. Для преодоления затруднений, возникающих в подобных и во многих других ситуациях, в Java предусмотрены оболочки типов — классы, инкапсулирующие простые типы данных. Классы оболочек типов упоминались в главе 10, а здесь они будут рассмотрены более подробно.

Оболочки типов реализуются в классах Double, Float, Long, Integer, Short, Byte, Character и Boolean, входящих в пакет java. lang. Эти классы предоставляют методы, позволяющие полностью интегрировать простые типы данных в иерархию объектов Java.

Чаще всего применяются оболочки типов, представляющие числовые типы данных: Byte, Short, Integer, Long, Float и Double. Все оболочки числовых типов данных являются производными от абстрактного класса Number. В классе Number определены методы, возвращающие значение объекта для каждого числового типа данных. Эти методы перечислены ниже.
```
byte byteValueO
double doubleValue()
float floatValue()
int intValue()
long longValue()
short shortValue()
```
Например, метод doubleValue() возвращает значение объекта как double, метод floatValue() — как float и т.д. Перечисленные выше методы реализуются каждым классом оболочки числового типа.

В каждом классе оболочки числового типа предусмотрены конструкторы, позволяющие сформировать объект на основе соответствующего простого типа данных или его строкового представления. Например, в классах Integer и Double имеются следующие конструкторы:
```
Integer(int пит)
Integer(String str)
Double(double num)
Double(String str)
```
Если параметр str не содержит допустимое строковое представление числового значения, генерируется исключение NumberFormatException.

Во всех оболочках типов переопределен метод toString(). Он возвращает из оболочки значение в удобной для чтения форме. Это позволяет выводить значения на экран, передавая объекты оболочек в качестве параметра методу, например println(), и не преобразуя их предварительно в простые типы данных.

Процесс инкапсуляции значения в оболочке типа называется упаковкой. До появления версии JDK 5 упаковка производилась вручную, т.е. программирующий на Java строил явным образом экземпляр класса оболочки с нужным значением. Например, для ручной упаковки значения 100 в объект типа Integer требовалась следующая строка кода:
```
Integer iOb = new Integer(100);
```
В данном примере явно создается объект типа Integer, в который упаковывается значение 100, а ссылка на этот объект присваивается переменной iOb.

Процесс извлечения значения из объекта оболочки называется распаковкой. До появления версии JDK 5 распаковка также производилась вручную, т.е. программирующему на Java приходилось вызывать явным образом соответствующий метод для объекта оболочки, чтобы извлечь значение, упакованное в этом объекте. Например, для распаковки значения из объекта iOb вручную и присваивания результата переменной int требовалась следующая строка кода:
```
int i = iOb.intValue();
```
В данном примере метод intValue() возвращает значение, упакованное в объект iOb как int.

Рассмотренные выше механизмы упаковки и распаковки демонстрируются в приведенном ниже примере программы.
```
// Упаковка и распаковка значений вручную,
class Wrap {
    public static void main(String args[]) {

        // Упаковка значения 100 производится вручную.
        Integer iOb = new Integer(100);

        // Распаковка значения 100 производится вручную.
        int i = iOb.intValue();

        System.out.println (i + " " + iOb) ; // отображает значения ЮОиЮО
    }
}
```
В данной программе целочисленное значение 100 упаковывается в объект типа Integer, на который ссылается переменная iOb. Для извлечения упакованного числового значения вызывается метод intValue(). Полученное значение сохраняется в переменной i. А в конце программы на экран выводятся значения переменных i и iOb, каждое из которых равно 100.

Аналогичная процедура использовалась в программах для упаковки и распаковки значений, начиная с ранних версий Java и до появления JDK 5. Но это не совсем удобно. Более того, создание объектов оболочек разных типов вручную может сопровождаться ошибками. Но теперь, с появлением автоупаковки и автораспаковки, обращаться с оболочками типов стало значительно проще.

### Основные положения о об автоупаковке
Автоупаковка — это процесс автоматической инкапсуляции (упаковки) простого типа данных в объекте оболочки соответствующего типа всякий раз, когда в этом возникает потребность, причем создавать такой объект явным образом не нужно. Автораспаковка — это процесс автоматического извлечения (распаковки) из объекта оболочки упакованного в нем значения соответствующего типа всякий раз, когда в этом возникает потребность. Благодаря автораспаковке отпадает необходимость в вызове таких методов, как intValue() и doubleValue().

Поддержка автоупаковки и автораспаковки существенно упрощает реализацию целого ряда алгоритмов, так как в этом случае все рутинные операции по упаковке и распаковке значений простых типов берет на себя исполняющая система Java, что позволяет уменьшить вероятность возникновения программных ошибок. Автоупаковка освобождает программирующего на Java от необходимости создавать вручную объекты для заключения в них простых типов данных. Достаточно присвоить упаковываемое значение переменной ссылки на объект оболочки соответствующего типа, а нужный объект будет автоматически создан исполняющей системой Java. Ниже приведен пример создания объекта типа Integer, в который автоматически упаковывается целочисленное значение 100.
```
Integer iOb = 100; // Автоупаковка целочисленного значения
```
Обратите внимание на то, что в данном примере отсутствует оператор new, конструирующий объект явным образом. Создание объекта происходит автоматически.

Для распаковки значения из объекта достаточно присвоить переменной простого типа ссылку на этот объект. Например, для распаковки значения, упакованного в объекте iOb, нужно лишь ввести в код следующую единственная строку:
```
int i = iOb; // Автораспаковка
```
А все остальное возьмет на себя исполняющая система Java. Ниже приведен пример программы, демонстрирующий автоупаковку и автораспаковку.
```
// Применение автоупаковки и автораспаковки,
class AutoBox {
    public static void main(String args[]) {

        // Автоупаковка и автораспаковка значения 100.
        Integer iOb = 100;
        int i = iOb;

        System.out.println(i + " " + iOb); // displays 100 100
    }
}
```

## Автоупаковка и методы
Автоупаковка и автораспаковка происходят не только в простых операциях присваивания, но и в тех случаях, когда простой тип требуется преобразовать в объект, и  наоборот. Следовательно, автоупаковка и автораспаковка могут происходить при передаче аргумента методу и при возврате значения последним. Рассмотрим в качестве примера следующую программу:
```
// Автоупаковка и автораспаковка при передаче
// параметров и возврате значений из методов.

class AutoBox2 {
    // Этот метод принимает параметр типа Integer.
    static void m(Integer v) {
        System.out.println("m() received " + v);
    }

    // Этот метод возвращает значение типа int.
    static int m2() {
        return 10;
    }

    // Этот метод возвращает значение типа Integer.
    static Integer m3() {
        return 99; // Автоупаковка значения 99 в объект типа Integer.
    }

    public static void main(String args[]) {
        // Передача методу m() значения типа int.
        // Метод m() принимает параметр типа Integer,
        // поэтому значение int автоматически упаковывается,
        m(199);

        // Здесь объект ЮЬ получает значение типа int, возвращаемое
        // методом т2(). Это значение автоматически упаковывается,
        // чтобы его можно было присвоить объекту iOb.
        Integer iOb = m2();
        System.out.println("Return value from m2() is " + iOb);

        // А здесь метод m3() возвращает значение типа Integer, которое
        // автоматически распаковывается и преобразуется в тип int.
        int i = m3();
        System.out.println("Return value from m3() is " + i);

        // Здесь методу Math.sqrt() в качестве параметра передается
        // объект iOb, который автоматически распаковывается, а его
        // значение продвигается к типу double, требующемуся для
        // выполнения данного метода.
        iOb = 100;
        System.out.println("Square root of iOb is " + Math.sqrt(iOb));
    }
}
```
Результат выполнения данной программы выглядит так:
```
m() received 199
Return value from m2() is 10
Return value from m3() is 99
Square root of iOb is 10.0
```
В объявлении метода m() указывается, что ему должен    передаваться    параметр    типа
Integer. В методе main() целочисленное значение    199 передается методу m()  в качестве параметра. В итоге происходит автоупаковка этого целочисленного значения. Далее в программе вызывается метод m2 (), возвращающий целочисленное значения 10. Это значение присваивается переменной ссылки на объект iOb в методе main(). А поскольку объект iOb относится к типу Integer, то целочисленное значение, возвращаемое методом m2 (), автоматически упаковывается. Затем в методе main() вызывается метод m3 (). Он возвращает объект типа Integer, который посредством автораспаковки преобразуется в тип int. И наконец, в методе main() вызывается метод Math. sqrt(), которому в качестве аргумента передается объект iOb. В данном случае происходит автораспаковка данного объекта, а его значение продвигается к типу double, поскольку параметр именно этого типа должен быть передан методу Math. sqrt().

## Автоупаковка и автораспаковка в выражениях
Автоупаковка и автораспаковка выполняются всякий раз, когда объект необходимо преобразовать в простой тип, а простой тип — в объект. Так, автораспаковка производится при вычислении выражений, и если требуется, то результат вычисления упаковывается. Рассмотрим в качестве примера приведенную ниже программу.
```
// Автоупаковка и автораспаковка в выражениях.
class AutoBox3 {
    public static void main(String args[]) {
        Integer iOb, i0b2;
        int i;

        iOb = 99;
        System.out.println("Original value of iOb: " + iOb);

        // В следующем выражении объект iOb автоматически
        // распаковывается, производятся вычисления, а результат
        // снова упаковывается в объект iOb.
        ++iOb;
        System.out.println("After ++iOb: и + iOb);

        // В последующем выражении производится автораспаковка
        // объекта iOb, к полученному значению прибавляется число 10,
        // а результат снова упаковывается в объект iOb.
        iOb += 10;
        System.out .println ("After iOb +=? 10: " + iOb) ;

        //И в следующем выражении объект iOb автоматически
        // распаковывается, выполняются вычисления, а результат
        // снова упаковывается в объект iOb.
        iOb2 = iOb + (iOb / 3);
        System.out.println("iOb2 after expression: " + iOb2);

        // А в этом случае вычисляется то же самое выражение,
        // но повторная упаковка не производится,
        i = iOb + (iOb / 3);

        System.out.println("i after expression: " + i);
    }
}
```
Выполнение этой программы дает следующий результат:
```
Original value of iOb: 99
After ++iOb: 100
After iOb += 10: 110
iOb2 after expression: 146
i after expression: 146
```
В данной программе особое внимание обратите на следующую строку кода:
```
++iOb;
```
В ней значение объекта iOb должно быть увеличено на единицу. Происходит это следующим образом: объект iOb распаковывается, полученное значение инкрементируется, а результат снова упаковывается в объект iOb.

Благодаря автораспаковке объекты оболочек целочисленных типов, например Integer, можно использовать в операторах switch. В качестве примера рассмотрим следующий фрагмент кода:
```
Integer iOb = 2;
switch(iOb) {
    case 1: System.out.println("one") ;
        break;
    case 2: System.out.println("two");
        break;
    default: System.out.println("error") ;
}
```
При вычислении выражения в операторе switch объект iOb распаковывается и последующей обработке подвергается значение типа int, упакованное в этом объекте.

Как следует из приведенных выше примеров, выражения, в которых применяются объекты оболочек простых типов, становятся интуитивно понятными благодаря автоупаковке и автораспаковке. До появления версии JDK 5 для достижения аналогичного результата в программе приходилось прибегать к приведению типов и вызовам специальных методов вроде intValue().

### Предупреждение относительно автоупаковки и автораспаковки
Теперь, когда автоупаковка и автораспаковка предельно упрощают обращение с оболочками простых типов, может возникнуть сильное искушение пользоваться вместо простых типов только их оболочками, например Integer или Double. Так, например, автоупаковка и автораспаковка позволяют создавать код, аналогичный приведенному ниже.
```
// Неоправданное использование автоупаковки и автораспаковки.
Double а, Ь, с;

а = 10.2;
b = 11.4;
с = 9.8;

Double avg = (a + b + c)./3;
```
В данном примере в объектах типа Double хранятся три значения, используемые для вычисления арифметического среднего, а полученный результат присваивается другому объекту типа Double. И хотя такой код формально считается корректным, а следовательно, будет выполняться правильно, тем не менее, автоупаковка и автораспаковка применяются в нем совершенно не оправданно. Ведь подобный код значительно менее эффективен аналогичного кода, написанного только с использованием переменных типа double. А каждая распаковка и упаковка связана с издержками, которые простые типы не налагают на вычислительные ресурсы.

Вообще говоря, в программировании на Java желательно поменьше пользоваться оболочками простых типов. Прибегать к ним следует лишь в тех случаях, когда действительно требуется объектное представление простых типов. Ведь автоупаковка и автораспаковка внедрены в Java не в качестве “лазейки”, употребляемой в обход простых типов данных.

## Статический импорт
Начиная с версии JDK 5 в Java была расширена область применения ключевого слова import, а именно: реализован механизм статического импорта. Указав после import ключевое слово static, можно сформировать выражение для импорта статических членов класса или интерфейса. Используя статический импорт, можно также ссылаться на статические члены непосредственно по именам, не указывая перед ними имена классов. Благодаря этому упрощается синтаксис и сокращается запись выражений, в которых применяются статические члены классов.

Для того чтобы оценить по достоинству возможности статического импорта, начнем его рассмотрение с примера, в котором это языковое средство не используется. Ниже проведен пример программы для решения следующего квадратного уравнения:
```
ах2 + bх + c = О
```
В этой программе применяются два статических метода — Math.pow() и Math, sqrt() — из класса Math, который, в свою очередь, входит в пакет j ava. lang. Первый из них возвращает значение, возведенное в заданную степень, а второй — квадратный корень значения своего параметра.
```
// Решение квадратного уравнения,
class Quadratic {
    public static void main(String args[]) {

        // Переменные a, b и с обозначают коэффициенты
        // квадратного уравнения ах2 + Ьх + с = О
        double а, Ь, с, х;

        // решить квадратное уравнение 4x2 + х - 3 = О
        а = 4;
        b = 1;
        с = -3 ;

        // найти первое решение
        х = (-b + Math.sqrt(Math.pow(b, 2) -    4   *   a * с)) / (2    *   a) ;
        System.out.println("First solution: " + x);

        // найти второе решение
        x = (-b - Math.sqrt(Math.pow(b, 2) -    4   *   a * c)) / (2    *   a) ;
        System.out.println("Second solution:    "   +   x);
    }
}
```
Методы pow() и sqrt() являются статическими, а следовательно, их нужно вызывать, ссылаясь на имя класса Math. Их вызов осуществляется в приведенном ниже выражении, хотя и нельзя не признать, что оно получается довольно громоздким.
```
х = (-b + Math.sqrt(Math.pow(b, 2) - 4 *    a   *   с)) / (2 * a)   ;
```
В таких выражениях приходится постоянно следить за тем, чтобы перед методами pow() и sqrt() (и другими подобными методами, например sin(), cos() и tan()) было указано имя класса, что неудобно и чревато ошибками.

Утомительной обязанности указывать всякий раз имя класса перед статическим методом позволяет избежать статический импорт. Его применение демонстрирует приведенная ниже версия предыдущей программы.
```
// Применение статического импорта с целью
// упростить вызовы методов sqrt() и pow().
// Средствами статического импорта обеспечивается
// непосредственный доступ к методам sqrt() и pow().
import static java.lang.Math.sqrt;

import static java.lang.Math.pow;
class Quadratic {
    public static void main(String args[]) {

        // Переменные a, b и с обозначают коэффициенты
        // квадратного уравнения ах2 + Ьх + с = О
        double а, Ь, с, х;

        // решить квадратное уравнение 4x2 + х - 3 = О
        а = 4;
        b = 1;
        с = -3;

        // найти первое решение
        х = (-b + sqrt(pow(b, 2) - 4 * а * с)) / (2 * а);
        System.out.println("First solution: " + x) ;

        // найти второе решение
        x = (-b - sqrt(pow(b, 2) - 4 * a * c)) / (2 * a) ;
        System.out.println("Second solution: " + x);
    }
}
```
В данной версии программы имена методов sqrt и pow уже не нужно указывать полностью (т.е. вместе с именем их класса). И достигается это благодаря статическому импорту обоих методов в приведенных ниже операторах, делающих оба метода непосредственно доступными.
```
import static java.lang.Math.sqrt;
import static java.lang.Math.pow;
```
После статического импорта отпадает необходимость предварять имена методов sqrt() и pow() именем их класса. В итоге выражение для решения квадратного уравнения принимает следующий вид:
```
х = (-b + sqrt(pow(b, 2) - 4 * а * с)) / (2 * а) ;
```
Теперь оно выглядит проще и воспринимается намного лучше. В Java предусмотрены две общие формы оператора import static. В первой форме, использованной в предыдущем примере, непосредственно доступным для программы делается единственное имя. Йиже приведена эта общая форма статического импорта.
```
import static пакет.имя_типа. имя_статического_члена;
```
где имя_типа обозначает класс или интерфейс, содержащий требуемый статический член, на который указывает имя_статического_члена. Вторая общая форма оператора статического импорта выглядит следующим образом:
```
import static пакет.имя_типа.*;
```
Если предполагается использовать несколько статических методов или полей, определенных в классе, то данная общая форма записи позволяет импортировать все эти члены одновременно. Таким образом, обеспечить непосредственный доступ к методам pow() и sqrt() в предыдущей версии программы (а также к другим статическим членам класса Math) без указания имени класса можно с помощью следующей единственной строки кода:
```
import static java.lang.Math.*;
```
Очевидно, что статический импорт не ограничивается только классом Math и его методами. Так, если требуется сделать непосредственно доступным статическое поле System, out потока стандартного вывода, в программу достаточно ввести следующую строку кода:
```
import static java.lang.System.out;
```
После этого данные можно выводить на консоль, не указывая перед статическим полем out имя его класса System:
```
out.println("After importing System.out, you can use out directly.");
```
Насколько целесообразно поступать именно так — вопрос спорный. С одной стороны, размер исходного кода в этом случае сокращается. А с другой стороны, тем, кто просматривает исходный код программы, может быть непонятно, что конкретно обозначает имя out: поток стандартного вывода System, out или нечто иное.

Каким бы удобным ни был статический импорт, важно следить за тем, чтобы он применялся правильно. Как известно, библиотеки классов Java организованы в пакеты именно для того, чтобы исключить конфликты имен. Если импортируются статические члены класса, они переносятся в глобальное пространство имен. Вследствие этого увеличивается вероятность конфликтов и неумышленного сокрытия имен. Если статический член используется в программе один или два раза, то импортировать его нет никакого смысла. Кроме того, некоторые имена статических членов (например, System, out) настолько знакомы всем программирующим на Java, что они окажутся менее узнаваемыми, если будут употребляться без имени своего класса. Статический импорт был внедрен в расчете на те программы, в которых постоянно применяются определенные статические члены, например при математических расчетах. Следовательно, статическим импортом следует пользоваться аккуратно, не злоупотребляя им.

## Аннотации (метаданные)
Начиная с версии JDE 5 в Java внедрено средство, позволяющее включать в исходный файл дополнительные сведения, которые называются аннотацией и не изменяют поведение программы. Эти сведения можно использовать в различных инструментальных средствах как на этапе разработки, так и в процессе развертывания прикладных программ. В частности, аннотации могут быть обработаны генератором исходного кода, компилятором или средствами развертывания прикладных программ. Дополнительные сведения, включаемые в исходный файл, иногда еще называют метаданными, но термин аннотация точнее отражает их назначение.

Вопросы составления и применения аннотаций выходят за рамки этой книги. Для подробного их рассмотрения здесь просто недостаточно места. Поэтому ограничимся лишь кратким описанием самого понятия и назначения аннотаций.

*На заметку*
Подробнее с метаданными и аннотациями можно ознакомиться в книге Java. Полное руководство, 8-е издание, ИД "Вильямс", 2012 г.

Для составления аннотаций служит ключевое слово interface. Ниже приведен простой пример объявления аннотации.
```
// Простой пример аннотации.
@interface MyAnno {
    String str();
    int val();
}
```
В данном примере объявляется аннотация MyAnno. Обратите внимание на то, что ключевое слово interface предваряется знаком @. Таким образом компилятору сообщается об объявлении аннотации. Обратите также внимание на два члена — str() и val(). Все аннотации содержат лишь объявления методов, а их тела указывать нельзя. Объявленные методы реализует исполняющая система Java, причем они действуют подобно полям.

Аннотации всех типов автоматически расширяют интерфейс Annotation. Следовательно, Annotation служит в качестве суперинтерфейса для всех аннотаций. Он входит в пакет java.lang.annotation.

Объявив аннотацию, ее можно использовать для аннотирования объявления. Аннотацию можно связать с любым объявлением. В частности, аннотированными могут быть объявления классов, методов, полей, параметров, констант перечислимого типа и даже самих аннотаций. Но в любом случае аннотация предшествует остальной части объявления.

Применяя аннотацию, вы тем самым задаете значения ее членов. Ниже приведен пример аннотации MyAnno, применяемой к методу.
```
// Аннотирование метода.
@MyAnno(str = "Annotation Example", val = 100)
public static void myMeth() { // ...
```
Эта аннотация связывается с методом myMeth(). Обратите внимание на синтаксис аннотации. Имени аннотации предшествует знак @, а после имени следует список, предназначенный для инициализации ее членов. Для того чтобы задать значение члена аннотации, следует присвоить это значение имени данного члена. В рассматриваемом здесь примере символьная строка "Annotation Example" (Пример аннотации) присваивается члену str аннотации MyAnno. Обратите внимание на то, что в операторе присваивания скобки после члена str не указываются. При присваивании значения члену аннотации используется только его имя. В этом отношении члены аннотации похожи на поля.

Аннотация без параметров называется маркером. При определении маркера круглые скобки не указываются. Главное назначение маркера — пометить объявление некоторым атрибутом.

В Java определено немало встроенных аннотаций. Некоторые из них считаются аннотациями общего назначения, но большинство являются специализированными. В пакет java.lang.annotation входят аннотации @Retention, @Documented, @Target и @Inherited. Аннотации @Override, @Deprecated и @SuppressWarnings включены в пакет ava.lang. Назначение этих семи аннотаций приведено в табл. 12.1.

Таблица 12.1. Встроенные аннотации

| Аннотация         | Описание                                                                                                                                                                                                                                                                                                                                                                                    |
|-------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| @Retention        | Определяет правила сохранения, связываемые с аннотацией. Правила сохранения определяют, как долго аннотация будет присутствовать в процессе компиляции и развертывания прикладной программы                                                                                                                                                                                                 |
| @Documented       | Маркер, сообщающий инструментальному средству о том, что аннотация документируется. Желательно использовать только как аннотацию к аннотации объявления                                                                                                                                                                                                                                     |
| @Target           | Задает виды объявлений, к которым может быть применена аннотация. Желательно использовать только в качестве одной аннотации к другой. Данная аннотация принимает аргумент в виде константы перечислимого типа ElementType, в котором определены различные константы, в том числе CONSTRUCTOR, FIELD и METHOD. Аргумент определяет виды объявлений, к которым может быть применена аннотация |
| @Inherited        | Маркер, указывающий на то, что аннотация суперкласса должна наследоваться подклассом                                                                                                                                                                                                                                                                                                        |
| @Override         | Метод, аннотированный как @Override, должен переопределять метод суперкласса. Если это условие не выполняется, возникает ошибка при компиляции. Данная аннотация представляет собой маркер и позволяет убедиться в том, что метод суперкласса действительно переопределен, а неперегружен                                                                                                   |
| @Deprecated       | Маркер, указывающий на то, что объявление устарело и было заменено новым                                                                                                                                                                                                                                                                                                                    |
| @SuppressWarnings | Указывает на то, что одно или несколько предупреждающих сообщений, которые могут быть сгенерированы при компиляции, должны быть подавлены. Предупреждающие сообщения задаются именами, представленными в строковом виде                                                                                                                                                                     |

Ниже приведен пример, в котором аннотацией @Deprecated помечаются класс MyClass и метод getMsg(). При попытке скомпилировать программу будет выведено сообщение о том, что в исходном коде содержатся устаревшие и не рекомендованные к применению элементы.
```
// Пример использования аннотации @Deprecated.

// Пометить класс как не рекомендованный к применению.
@Deprecated
class MyClass {
    private String msg;

    MyClass(String m) {
        msg = m;
    }

    // Пометить метод в классе как
    // не рекомендованный к применению.
    @Deprecated
    String getMsgO {
        return msg;
    }

    // ...
}

class AnnoDemo {
    public static void main(String args[]) {
        MyClass myObj = new MyClass("test");

        System.out.println(myObj.getMsg());
    }
}
```

## Упражнение для самопроверки по материалу главы 12
1. Константы перечислимого типа иногда называют самотипизированными. Что это означает?
2. Какой класс автоматически наследуют перечисления?
3. Напишите для приведенного ниже перечисления программу, в которой метод values() служит для отображения списка констант и их значений.
    ```
    enum Tools {
        SCREWDRIVER, WRENCH, HAMMER, PLIERS
    }
    ```
4. Программу, имитирующую автоматизированный светофор и созданную в примере для опробования 12.1, можно усовершенствовать, внеся ряд простых изменений, чтобы выгодно воспользоваться возможностями перечислений. В исходной версии этой программы продолжительность отображения каждого цвета светофора регулировалась в классе Traf f icLightSimulator, причем величины задержек были жестко запрограммированы в методе run(). Измените исходный код программы таким образом, чтобы продолжительность отображения каждого цвета светофора задавалась константами перечислимого типа Traf f icLightColor. Для этого вам понадобятся конструктор, переменная экземпляра, объявленная как private, а также метод getDelay(). Подумайте о том, как еще можно улучшить данную программу. (Подсказка: попробуйте отказаться от оператора switch и воспользоваться порядковыми значениями каждого цвета для переключения светофора.)
5. Что такое упаковка и распаковка? В каких случаях производится автоупаковка и автораспаковка?
6. Измените следующий фрагмент кода таким образом, чтобы в нем производилась автоупаковка:
    ```
    Short val = new Short (123);
    ```
7. Объясните, что такое статический импорт?
8. Какие действия выполняет приведенный ниже оператор?
    ```
    import static java.lang.Integer.parselnt;
    ```
9. Следует ли употреблять статический импорт от случая к случаю или желательно импортировать статические члены всех классов?
10. Синтаксис аннотации основывается на .
11. Какая аннотация называется маркером?
12. Аннотации применимы только к методам. Верно или неверно?