# Глава 2
# Введение в типы данных и операторы

Основные навыки и понятия
* Представление о простых типах данных в Java
* Применение литералов
* Инициализация переменных
* Правила соблюдения области действия переменных в методе
* Применение арифметических операторов
* Применение операторов сравнения и логических операторов
* Представление об операторах присваивания
* Представление об укороченных операторах присваивания
* Преобразование типов при присваивании
* Представление о неприводимых типах данных
* Преобразование типов в выражениях

Основу любого языка программирования составляют типы данных и операторы, и Java не является исключением из этого правила. Типы данных и операторы определяют область применимости языка и круг задач, которые можно успешно решать с его помощью. В Java поддерживаются самые разные типы данных и операторы, что делает этот язык универсальным и пригодным для написания любых программ.

Значение типов данных и операций нельзя недооценивать. Эта глава начинается с анализа основных типов данных и наиболее часто используемых операторов. А кроме того, в ней будут подробно рассмотрены переменные и выражения.

## Особое значение типов данных
В связи с тем, что Java относится к категории строго типизированных языков программирования, типы данных имеют в нем очень большое значение. В процессе компиляции проверяются типы операндов во всех операциях. И если в программе встречаются недопустимые операции, ее исходный код не преобразуется в байт-код. Контроль типов позволяет сократить количество ошибок и повысить надежность программы. В отличие от других языков программирования, где допускается не указывать типы данных, хранящихся в переменных, в Java все переменные, выражения и значения строго контролируются на соответствие типов данных. Более того, тип переменной определяет, какие именно операции могут быть выполнены над ней. Операции, разрешенные для одного типа данных, могут оказаться недопустимы для другого.

## Простые типы данных в Java
Встроенные типы данных в Java разделяются на две категории: объектно-ориентированные и необъектно-ориентированные. Объектно-ориентированные типы данных определяются в классах, о которых речь пойдет далее в книге. В основу языка Java положено восемь простых типов данных, приведенных в табл. 2.1 (их также называют элементарными, или примитивными). Термин простые указывает на то, что эти типы данных являются не объектами, а обычными двоичными значениями. Такие типы данных предусмотрены в языке для того, чтобы увеличить эффективность работы программ. Все остальные типы данных Java образуются на основе простых типов.

В Java четко определены области действия простых типов и диапазон допустимых для них значений. Эти правила должны соблюдаться при создании всех виртуальных машин. А поскольку программы на Java должны быть переносимыми, точное следование этим правилам является одним из основных требований языка. Например, тип int остается неизменным в любой исполняющей среде, благодаря чему удается обеспечить реальную переносимость программ. Это означает, что при переходе с одной платформы на другую не приходится переписывать код. И хотя строгий контроль типов может привести к незначительному снижению производительности в некоторых исполняющих средах, он является обязательным условием переносимости программ.

Таблица 2.1. Простые типы, встроенные в Java

| Тип     | Описание                                                |
|---------|---------------------------------------------------------|
| boolean | Представляет логические значения true и false           |
| byte    | 8-разрядное целое число                                 |
| char    | Символ                                                  |
| double  | Числовое значение с плавающей точкой двойной точности   |
| float   | Числовое значение с плавающей точкой одинарной точности |
| int     | Целое число                                             |
| long    | Длинное целое число                                     |
| short   | Короткое число                                          |

## Целочисленные типы данных

В Java определены четыре целочисленных типа данных: byte, short, int и long. Их краткое описание приведено ниже.

| Тип   | Разрядность, бит | Диапазон допустимых значений                               |
|-------|------------------|------------------------------------------------------------|
| byte  | 8                | от-128 до 127                                              |
| short | 16               | от -32,768 до 32,767                                       |
| int   | 32               | от -2,147,483,648 до 2,147,483,647                         |
| long  | 64               | от -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807 |

Как следует из приведенной выше таблицы, целочисленные типы данных предполагают как положительные, так и отрицательные значения. В Java не поддерживаются целочисленные значения без знака, т.е. только положительные целые числа. Во многих других языках программирования широко применяются целочисленные типы данных без знака, но создатели Java посчитали их излишними.

*На заметку*
В исполняющей системе Java для хранения простых типов может формально выделяться любой объем памяти, но диапазон допустимых значений остается неизменным.

Из всех целочисленных типов данных чаще всего применяется int. Переменные типа int нередко используются в качестве переменных циклов, индексов массивов и, конечно же, для выполнения универсальных операций над целыми числами.

Если диапазон значений, допустимых для типа int, не устраивает, можно выбрать тип long. Ниже приведен пример программы для расчета числа кубических дюймов в кубе, длина, ширина и высота которого равны одной миле.

```
/*
Расчет числа кубических дюймов в кубе объемом в 1 милю.
*/
class Inches {
    public static void main(String args[])  {
        long ci;
        long im;
        im = 5280 * 12;
        ci = im * im * im;
        System.out.println("There are " + ci +
                            " cubic inches in cubic mile.");
    }
}
```
Результат выполнения данной программы выглядит следующим образом:
```
There are 254358061056000 cubic inches in cubic mile.
```
Очевидно, что результирующее значение не умещается в переменной типа int.

Наименьшим диапазоном допустимых значений среди всех целочисленных типов обладает тип byte. Переменные типа byte очень удобны для обработки исходных двоичных данных, которые могут оказаться несовместимыми с другими встроенными в Java типами данных. Тип short предназначен для хранения небольших целых чисел. Переменные данного типа пригодны для хранения значений, изменяющихся в относительно небольших пределах по сравнению со значениями типа int.

## Типы данных с плавающей точкой
Как пояснялось в главе 1, типы с плавающей точкой могут представлять числовые значения с дробной частью. Существуют два типа данных с плавающей точкой: float и double. Они представляют числовые значения с одинарной и двойной точностью соответственно. Разрядность данных типа float составляет 32 бита, а разрядность данных типа double — 64 бита.

Тип double употребляется намного чаще, чем float, поскольку во всех математических функциях из библиотек классов Java используются значения типа double. Например, метод sqrt(), определенный в стандартном классе Math, возвращает значение double, являющееся квадратным корнем значения аргумента этого метода, также представленного типом double. Ниже приведен фрагмент кода, в котором метод sqrt() используется для расчета длины гипотенузы треугольника, при условии, что заданы длины катетов.

```
/*
Определение длины гипотенузы, исходя из длины катетов по теореме Пифагора.
*/
class Hypot {
    public static void main(String args[]) {
        double x, y, z;

        x = 3;
        У = 4;

        // Обратите внимание на вызов метода sqrt(). Перед именем метода
        // указывается имя класса, членом которого он является.
        z = Math.sqrt(х*х + у*у);

        System.out.println("Hypotenuse is " + z) ;
    }
}
```
Выполнение этого фрагмента кода дает следующий результат:
```
Hypotenuse is 5.0
```
Как упоминалось выше, метод sqrt() определен в стандартном классе Math. Обратите внимание на вызов этого метода в приведенном выше фрагменте кода: перед его именем указывается имя класса. Аналогичным образом перед именем метода println() указывается имена классов System.out. Имя класса указывается не перед всеми стандартными методами, но для некоторых из них целесообразно применять именно такой способ.

## Символы
В отличие от других языков в Java символы не являются 8-битовыми значениями. Вместо этого в Java символы всех языков мира представлены в уникоде (Unicode). Таким образом, в Java тип char представляет 16-разрядное значение без знака в диапазоне от О до 65536. Стандартный набор 8-разрядных символов в коде ASCII является подмножеством уникода. В нем коды символов находятся в пределах от 0 до 127. Следовательно, символы в коде ASCII по-прежнему допустимы в Java.

Переменной символьного типа может быть присвоено значение, которое записывается в виде символа, заключенного в одинарные кавычки. В приведенном ниже фрагменте кода показано, каким образом переменной ch присваивается буква S.
```
char ch;
ch = 'S’;
```
Отобразить значение типа char можно с помощью метода println(). В приведенной ниже строке кода показано, каким образом этот метод вызывается для вывода на экран значения символа, хранящегося в переменной ch.
```
System.out.println("This is ch:" + ch) ;
```
Тип char представляет 16-разрядное значение без знака, а это означает, что над пе ременной символьного типа можно производить различные арифметические операции. Рассмотрим в качестве примера следующую программу:
```
//С символьными переменными можно обращаться, как с целочисленными,
class CharArithDemo {
    public static void main(String args[]) {
        char ch;

        ch = ' X' ;
        System.out.println("ch contains " + ch) ;

        ch++; // переменную типа char можно инкрементировать
        System.out.println("ch is now " + ch) ;

        ch = 90; // переменной типа char можно присвоить целочисленное значение
        System.out.println("ch is now " + ch) ;
    }
}
```
Ниже приведен результат выполнения данной программы.
```
ch contains X
ch is now Y
ch is now Z
```

В приведенной выше программе переменной ch сначала присваивается значение кода буквы X. Затем содержимое ch увеличивается на единицу, в результате чего оно превращается в код буквы Y — следующего по порядку символа в коде ASCII (а также в уникоде). После этого переменной ch присваивается значение 90, представляющее букву Z в коде ASCII (и в уникоде). А поскольку символам в коде ASCII соответствуют первые 127 значений в уникоде, то все приемы, обычно применяемые для манипулирования символами в других языках программирования, вполне работоспособны и в Java.

## Логический тип данных
Тип boolean представляет логические значения “истина” и “ложь”, для которых в Java зарезервированы слова true и false соответственно. Следовательно, переменная или выражение типа boolean может принимать одно из этих двух значений.

Ниже приведен пример программы, демонстрирующий применение типа boolean в коде.

```
// Демонстрация обращения с логическими значениями,
class BoolDemo {
    public static void main(String args[]) {
        boolean b;
        b = false;
        System.out.println("b is " + b);
        b = true;
        System.out.println("b is " + b);
        // Логическое значение можно использовать для
        // управления условным оператором if.
        if(b) System.out.println("This is executed.");
        b = false;
        if(b) System.out.println("This is not executed.");
        // Логическое значение получается в результате
        // выполнения оператора отношения.
        System.out.println("10 > 9 is " + (10 > 9));
    }
}
```
Результат выполнения данной программы выглядит следующим образом:
```
b is false
b is true
This is executed.
10 > 9 is true
```
Анализируя приведенную выше программу, необходимо отметить следующее. Во-первых, нетрудно заметить, что метод println(), обрабатывая логическое значение, отображает символьные строки "true" и "false". Во-вторых, значение логической переменной может быть само использовано для управления условным оператором if. Это означает, что отпадает необходимость в выражениях вроде следующего:
```
if(b == true) . . .
```
И в-третьих, результатом выполнения оператора отношения, например <, является логическое значение. Именно поэтому при передаче методу println() выражения (10 >9) отображается логическое значение true. Скобки в данном случае необходимы, потому что оператор + имеет более высокий приоритет, чем оператор >.

**Пример для опробования 2.1.**
Расчет расстояния до удара молнии

В данном проекте предстоит написать программу, вычисляющую расстояние в футах до источника звука при ударе молнии. Звук распространяется в воздухе со скоростью, приблизительно равной 1100 футам в секунду. Следовательно, зная промежуток времени между теми моментами, когда наблюдатель увидит вспышку молнии и услышит сопровождающий ее раскат грома, можно рассчитать расстояние до нее. Допустим, что этот промежуток времени составляет 7,2 секунды.

Последовательность действий
1. Создайте новый файл Sound. j ava.
2. Для расчета искомого расстояния потребуются числовые значения с плавающей точкой. Почему? А потому, что упомянутое выше числовое значение промежутка времени содержит дробную часть. И хотя для расчета достаточно точности, обеспечиваемой типом float, в данном примере будет использован тип double.
3. Для расчета искомого расстояния умножьте значение 7,2 на 1100, а полученный результат сохраните в переменной типа double.
4. Выведите результат расчета на экран.
    Ниже приведен исходный код программы из файла Sound. j ava.
    ```
    /*
        Пример для опробования 2.1.
        Рассчитать расстояние до удара моЛнии, звук от которого
        доходит до наблюдателя через 7,2 с.
    */
    class Sound {
        public static void main(String args[]) {
            double dist;

            dist = 7.2 * 1100;

            System.out.println("The lightning is " + dist +
            " feet away.");
        }
    }
    ```
5.  Скомпилируйте программу и запустите ее на выполнение, чтобы вывести на экран следующий результат:
    ```
    The lightning is 7920.0 feet away.
    ```
6.  Усложним задачу. Рассчитать расстояние до крупного объекта, например скалы, можно по времени прихода эхо. Так, если вы хлопнете в ладоши, время, через которое вернется эхо, будет равно времени прохождения звука в прямом и обратном направлении. Разделив этот промежуток времени на два, вы получите время прохождения звука от вас до объекта. Это время можно затем использовать для расчета расстояния до объекта. Видоизмените рассмотренную выше программу, использовав в качестве заданного промежутка время прихода эха.

## Литералы
В Java литералы применяются для представления постоянных значений в форме, удобной для восприятия. Например, число 100 является литералом. Литералы часто называют константами. Как правило, структура литералов и их использование интуитивно понятны. Они уже встречались в рассмотренных ранее примерах программ, а теперь пришло время дать им формальное определение. В Java предусмотрены литералы для всех простых типов. Способ представления литерала зависит от типа данных. Как пояснялось ранее, константы, соответствующие символам, заключаются в одинарные кавычки. Например, и 1 а1, и 1 %1 являются символьными константами.

Целочисленные константы записываются как числа без дробной части. Например, целочисленными константами являются 10 и -100. При формировании константы с плавающей точкой необходимо указывать десятичную точку, после которой следует дробная часть. Например, 11,123 — это константа с плавающей точкой. В Java поддерживается и так называемый экспоненциальный формат представления чисел с плавающей точкой.

По умолчанию целочисленные литералы относятся к типу int. Если же требуется определить литерал типа long, после числа следует указать букву 1 или L. Например, 12 — это константа типа int, a 12L — литерал типа long. По умолчанию к типу double относятся и литералы с плавающей точкой. А для того чтобы задать литерал типа float, следует указать после числа букву F или f. Так, например, к типу float относится литерал 10,19F.

Несмотря на то что целочисленные литералы по умолчанию создаются как зна¬ чения типа int, их можно присваивать переменным типа char, byte, short и long. Присваиваемое значение приводится к целевому типу. Переменной типа long можно также присвоить любое значение, представленное целочисленным литералом.

Начиная с версии JDK 7 появилась возможность вставлять в литералы (как целочисленные, так и с плавающей точкой) знаки подчеркивания. Благодаря этому упрощается восприятие числовых значений, состоящих из нескольких цифр. А при компиляции знаки подчеркивания просто удаляются из литерала. Ниже приведен пример литерала со знаком подчеркивания.
```
123_45_1234
```
Этот литерал задает числовое значение 123451234. Пользоваться знаками подчеркивания особенно удобно при кодировании номеров деталей, идентификаторов заказчиков и кодов состояния, которые обычно состоят из целых групп цифр.

### Шестнадцатеричные, восьмеричные и двоичные литералы
Вам, вероятно, известно, что при написании программ бывает удобно пользоваться числами, представленными в системе счисления, отличающейся от десятичной. Для этой цели чаще всего выбирается восьмеричная (с основанием 8) и шестнадцатеричная (с основанием 16) системы счисления. В восьмеричной системе используются цифры от 0 до 7, а число 10 соответствует числу 8 в десятичной системе. В шестнадцатеричной системе используются цифры от 0 до 9, а также буквы от А до F, которыми обозначаются числа 10, 11, 12, 13, 14 и 15 в десятичной системе, тогда как число 10 в шестнадцатеричной системе соответствует десятичному числу 16. Восьмеричная и шестнадцатеричная системы используются очень часто в программировании, и поэтому в языке Java предусмотрена возможность представления целочисленных констант (или литералов) в восьмеричной и шестнадцатеричной форме. Шестнадцатеричная константа должна начинаться с символов Ох (цифры 0, после которой следует буква х). А восьмеричная константа начинается с нуля. Ниже приведены примеры таких констант.
```
hex = OxFF; // Соответствует десятичному числу 255
oct = 011; // Соответствует десятичному числу 9
```
Любопытно, что в Java допускается также задавать шестнадцатеричные литералы в формате с плавающей точкой, хотя они употребляются очень редко. Начиная с версии JDK 7 появилась также возможность задавать целочисленный литерал в двоичной форме. Для этого перед целым числом достаточно указать символы ОЬ или ОВ. Например, следующий литерал определяет целое значение 12 в двоичной форме:
```
0b1100.
```

### Символьные управляющие последовательности
Заключая большинство печатных символов в одинарные кавычки, можно обращаться с ними как с символьными константами, но для непечатных символов, например возврата каретки, требуется специальное символьное представление. Кроме того, некоторые знаки, например одинарные и двойные кавычки, имеют специальное назначение, и поэтому их нельзя непосредственно указывать в качестве литерала. По этой причине в языке Java предусмотрены специальные управляющие последовательности, начинающиеся с обратной косой черты (и нередко называемые константами с обратной косой чертой). Эти последовательности перечислены в табл. 2.2. Они используются в литералах вместо непечатных символов, которые они представляют.

Таблица 2.2. Символьные управляющие последовательности

| Управляющая последовательность | Описание                                                        |
|--------------------------------|-----------------------------------------------------------------|
| \'                             | Одинарная кавычка                                               |
| \"                             | Двойная кавычка                                                 |
| \\                             | Обратная косая черта                                            |
| \r                             | Возврат каретки                                                 |
| \n                             | Перевод строки                                                  |
| \f                             | Перевод страницы                                                |
| \t                             | Горизонтальная табуляция                                        |
| \b                             | Возврат на одну позицию                                         |
| \ddd                           | Восьмеричная константа (где ddd —восьмеричное число)            |
| \uxxxx                         | Шестнадцатеричная константа (где хххх —шестнадцатеричное число) |

Ниже приведен пример присваивания переменной ch символа табуляции.
```
ch = '\t';
```
А в следующем примере переменной ch присваивается одинарная кавычка:
```
ch = '\'';
```

## Строковые литералы
В Java предусмотрены также литералы для представления символьных строк. Символьная строка — это набор символов, заключенных в двойные кавычки, как в приведенном ниже примере.
```
"this is a test"
```
Примеры строковых литералов не раз встречались в рассмотренных ранее примерах программ. В частности, они передавались в качестве аргументов методу println().

Помимо обычных символов, строковый литерал может также содержать упоминавшиеся выше управляющие последовательности. Рассмотрим в качестве примера следующую программу, в которой применяются управляющие последовательности \п и \t:
```
// Демонстрация управляющих последовательностей в символьных строках,
class StrDemo {
    public static void main(String args[]) {
        // В следующей строке кода в символьную строку введена
        // управляющая последовательность \п для перевода строки.
        System.out.println("First line\nSecond line");
        // В двух последующих строках кода в символьную строку введена
        // управляющая последовательность \t для выравнивания выводимых
        // результатов с помощью табуляции.
        System.out.println("A\tB\tC") ;
        System.out.println("D\tE\tF") ;
    }
}
```
Ниже приведен результат выполнения данной программы.
```
First line
Second line
A   B   C
D   E   F
```
Обратите внимание на использование управляющей последовательности \п для перевода строки в приведенном выше примере программы. Для вывода на экран нескольких символьных строк, совсем не необязательно вызывать метод println() несколько раз подряд. Достаточно ввести в строку символы \п, и при выводе в этом месте произойдет переход на новую строку.

## Подробнее о переменных
О переменных уже шла речь в главе 1. А здесь они будут рассмотрены более подробно. Как вы уже знаете, переменная объявляется в такой форме:
```
тип имя_переменной;
```
где тип обозначает конкретный тип объявляемой переменной, а имя_переменной — ее наименование. Объявить можно переменную любого допустимого типа, включая рассмотренные ранее простые типы. Когда объявляется переменная, создается экземпляр соответствующего типа. Следовательно, возможности переменной определяются ее типом. Например, переменную типа boolean нельзя использовать для хранения значения с плавающей точкой. На протяжении всего срока действия переменной ее тип остается неизменным. Так, переменная int не может превратиться в переменную char.

В Java каждая переменная должна быть непременно объявлена перед ее употреблением. Ведь компилятору необходимо знать, данные какого именно типа содержит переменная, и лишь тогда он сможет правильно скомпилировать оператор, в котором используется переменная. Объявление переменных позволяет также осуществлять строгий контроль типов в Java.

### Инициализация переменных
Прежде чем использовать переменную в выражении, ей нужно присвоить значение. Сделать это можно, в частности, с помощью уже знакомого вам оператора присваивания. Существует и другой способ: инициализировать переменную при ее объявлении. Для этого достаточно указать после имени переменной знак равенства и требуемое значение. Ниже приведена общая форма инициализации переменной.
```
тип переменная = значение;
```
где значение обозначает конкретное значение, которое получает переменная при ее создании. А тип значения должен быть совместим с типом переменной. Ниже приведен ряд примеров инициализации переменных.
```
int count = 10; // присвоить переменной count начальное значение 10
char ch = 'S';  //  инициализировать переменную ch буквой S
float f = 1.2F; // инициализировать переменную f числовым значением 1,2
```
Присваивать начальные значения переменным можно и в том случае, если в одном операторе объявляется несколько переменных, как в приведенном ниже примере.
```
int а, Ь=8, с =19, d; // инициализируются переменные b и с
```
В данном случае инициализируются переменные b и с.

### Динамическая инициализация
В приведенных выше примерах в качестве значений, присваиваемых переменным, использовались только константы. Но в Java поддерживается также динамическая инициализация, при которой можно использовать любые выражения, допустимые в момент объявления переменной. Ниже приведен пример простой программы, в которой объем цилиндра рассчитывается, исходя из его радиуса и высоты.
```
// Демонстрация динамической инициализации,
class Dynlnit {
    public static void main(String args[])  {
        double radius = 4, height = 5;

        // Переменная volume инициализируется динамически
        //во время выполнения программы.
        double volume = 3.1416 * radius * radius * height;

        System.out.println("Volume is " + volume);
    }
}
```
В данном примере используются три локальные переменные: radius, height и volume. Первые две из них инициализируются константами, а для присвоения значения переменной volume применяется динамическая инициализация, в ходе которой вычисляется объем цилиндра. В выражении динамической инициализации можно использовать любой определенный к этому моменту элемент, в том числе вызовы методов, другие переменные и литералы.

### Область и срок действия переменных
Все использовавшиеся до сих пор переменные объявлялись в начале метода main(). Но в Java можно объявлять переменные в любом кодовом блоке. Как пояснялось в главе 1, кодовый блок начинается с открывающей фигурной скобки и оканчивается закрывающей фигурной скобкой. Блок определяет область действия переменных. Начиная новый блок, вы всякий раз создаете новую область действия. По существу, область действия определяет доступность объектов из других частей программы и срок их действия.

Во многих языках программирования поддерживаются две общие категории областей действия: глобальная и локальная. И хотя они поддерживаются и в Java, тем не менее не относятся к самым лучшим средствам для определения пределов действия объектов. Намного большее значение в Java имеют области, определяемые классом и методом. Об областях действия, определяемых классом (и объявляемых в них переменных), речь пойдет далее в этой книге, когда дойдет черед до рассмотрения классов. А до тех пор исследуем только те области действия, которые определяются методами или в самих методах.

Начало области действия, определяемой методом, обозначает открывающая фигурная скобка. Если для метода предусмотрены параметры, они также входят в область его действия.

Как правило, переменные, объявленные в некоторой области действия, не видны (а следовательно, недоступны) за ее пределами. Следовательно, объявляя переменную в некоторой области действия, вы тем самым ограничиваете пределы ее действия и защищаете ее от нежелательного доступа и видоизменения. На самом деле правила определения области действия служат основанием для инкапсуляции.

Области действия могут быть вложенными. Открывая новый кодовый блок, вы создаете новую, вложенную область действия. Такая область заключена во внешней области. Это означает, что объекты, объявленные во внешней области действия, будут доступны для кода во внутренней области, но не наоборот. Объекты, объявленные во внутренней области действия, недоступны во внешней области.

Для того чтобы лучше понять принцип действия вложенных областей действия, рассмотрим следующий пример программы:
```
// Демонстрация области действия кодового блока,
class ScopeDemo {
    public static void main(String args[ ] )    {
        int x; // эта переменная доступна для всего кода в методе main.

        х = 10;
        if(х == 10) {   // Начало новой области действия.
            int у = 20; // Эта переменная доступна только в данном кодовом блоке.

            // Обе переменные, х и у, доступны в данном кодовом блоке.

            System, out .println ("х and у: " + х + " 11 + у) ;
            х = у * 2;
        }
        // у = 100; // Ошибка! Переменная у недоступна эа пределами
                    // области своего действия

        // А переменная х по-прежнему доступна.
        System.out.println("х is " + х);
    }
}
```
Как следует из комментариев к приведенной выше программе, переменная х определяется в начале области действия метода main() и доступна для всего кода, содержащегося в этом методе. В блоке условного оператора if объявляется переменная у. Этот блок определяет область действия переменной у, и, следовательно, она доступна только в нем. Именно поэтому закомментирована строка кода у = 100;, находящаяся за пределами данного блока. Если удалить символы комментариев, то при компиляции программы появится сообщение об ошибке, поскольку переменная у недоступна для кода за пределами ее блока. В то же время в блоке условного оператора i f можно пользоваться переменной х, потому что код в блоке, который определяет вложенную область действия, имеет доступ к переменным из внешней, охватывающей его области действия.

Переменные можно объявлять в любом месте кодового блока, но сделать это следует непременно перед тем, как пользоваться ими. Именно поэтому переменная, определенная в начале метода, доступна для всего кода этого метода. А если объявить переменную в конце блока, то такое объявление окажется, по существу, бесполезным, поскольку переменная станет вообще недоступной для кода.

Следует также иметь в виду, что переменные, созданные в области их действия, удаляются, как только управление в программе передается за пределы этой области. Следовательно, после выхода из области действия переменной содержащееся в ней значение теряется. В частности, переменные, объявленные в теле метода, не хранят значения в промежутках между последовательными вызовами этого метода. Таким образом, срок действия переменной ограничивается областью ее действия.

Если при объявлении переменной осуществляется ее инициализация, то переменная будет повторно инициализироваться при каждом входе в тот блок, в котором она объявлена. Рассмотрим в качестве примера следующую программу:
```
// Демонстрация срока действия переменной,
class VarlnitDemo {
    public static void main(String args[]) {
        int x;

        for(x = 0; x < 3; x++)  {
            int у = -1; // переменная у инициализируется при каждом входе в блок
            System.out.println("у is: 11 + у); // всегда выводится значение -1
            у = 100;
            System.out.println("у is now: " + у);
        }
    }
}
```
Ниже приведен результат выполнения данной программы.
```
У is: -1
у is now: 100
у is: -1
у is now: 100
у is: : -1
у is now: 100
```
Как видите, на каждом шаге цикла for переменная у инициализируется значением -1. Затем ей присваивается значение 100, но по завершении кодового блока данного цикла оно теряется.

Для правил области действия в Java характерна следующая особенность: имя переменной во вложенном блоке не может совпадать с именем переменной во внешнем блоке. Рассмотрим следующий пример программы. В ней предпринимается попытка объявить две переменные с одним и тем же именем в разных областях действия, и поэтому она не подлежит компиляции.
```
/*
В этой программе предпринимается попытка объявить переменную
во внутренней области действия с таким же именем, как и у переменной,
определенной во внешней области действия.
*** Эта программа не подлежит компиляции. ***
*/
class NestVar {
    public static void main(String args[]) {
        int count; // Первое объявление переменной count
        for (count = 0; count < 10; count = count+1) {
            System.out.println("This is count: " + count);

            int count; // Второе объявление переменной count.
                       // Недопустимо, поскольку точно такая же
                       // переменная объявлена раньше!!!
            for(count = 0; count < 2; count++)
                System.out.println("This program is in error!");
        }
    }
}
```
Если у вас имеется некоторый опыт программирования на С или C++, то вам, вероятно, известно, что в этих языках отсутствуют какие-либо ограничения на имена переменных, объявляемых во внутренней области действия. Так, в С и C++ объявление переменной count в блоке внешнего цикла for из приведенного выше примера программы вполне допустимо, несмотря на то, что такая же переменная уже объявлена во внешнем блоке. В этом случае переменная во внутреннем блоке скрывает переменную из внешнего блока. Создатели Java решили, что подобное сокрытие имен переменных может привести к программным ошибкам, и поэтому запретили его.

## Операторы
В Java предусмотрено большое количество операторов. Оператор — это знак, указы вающий компилятору на необходимость выполнения определенного математического или логического действия. Операторы в Java делятся на четыре общие категории: арифметические, поразрядные, логические и отношения. Кроме того, в Java определены некоторые дополнительные операторы для применения в особых случаях. В этой главе будут рассмотрены арифметические и логические операторы, а также операторы отношения присваивания. А о поразрядных и специальных операторах речь пойдет далее в этой книге.

### Арифметические операторы
В языке Java определены следующие арифметические операторы.

| Оператор | Выполняемое действие              |
|----------|-----------------------------------|
| +        | Сложение (а также унарный плюс)   |
| -        | Вычитание (а также унарный минус) |
| *        | Умножение                         |
| /        | Деление                           |
| %        | Деление по модулю                 |
| ++       | Инкремент                         |
| --       | Декремент                         |

Операторы +, -, * и / действуют в Java таким же образом, как и в любом другом языке программирования в частности и математике вообще, т.е. выполняют обычные арифметические операции. Их можно применять к числовым данным встроенных типов. Они также применимы к объектам типа char.

Несмотря на то что арифметические операции хорошо всем известны, у них имеются некоторые особенности, требующие специального пояснения. Во-первых, если оператор / применяется к целым числам, остаток от деления отбрасывается. Например, результат целочисленного деления 10/3 равен 3. А для получения остатка от деления следует применить оператор деления по модулю %. В Java он действует таким же образом, как и в других языках программирования. Например, в результате операции 10 % 3 будет получено значение 1. Оператор % применяется не только к целым числам, но и к числам с плавающей точкой. Следовательно, в результате операции 10,0 % 3,0 также будет получено значение 1. Ниже приведен пример программы, демонстрирующий применение оператора %.
```
// Демонстрация оператора %.
class ModDemo {
    public static void main(String args[])  {
        int iresult, irem;
        double dresult, drem;

        iresult = 10 / 3;
        irem = 10 % 3;

        dresult = 10.0 / 3.0;
        drem = 10.0 % 3.0;

        System.out.println("Result and remainder of 10 / 3: " +
                            iresult + " " + irem);
        System.out.println("Result and remainder of 10.0 / 3.0: " +
                            dresult + " " + drem);
    }
}
```
Выполнение этой программы дает следующий результат:
```
Result and remainder of 10 / 3: 3 1
Result and remainder of 10.0 / 3.0: 3.3333333333333335 1.0
```
Как видите, оператор % возвращает остаток от деления как целых чисел, так и чисел с плавающей точкой.

### Операторы инкремента и декремента
Операторы ++ и —, выполняющие положительное (инкремент) и отрицательное (декремент) приращение значений, были уже представлены в главе 1. Как будет показано ниже, у этих операторов имеется ряд интересных особенностей. Рассмотрим подробнее действия, выполняемые операторами инкремента и декремента.

Оператор инкремента добавляет к своему операнду единицу, а оператор декремента вычитает единицу из операнда. Следовательно, оператор
```
х = х + 1;
```
дает такой же результат, как и оператор
```
х++;
```
а оператор
```
х = х - 1;
```
дает такой же результат, как и оператор
```
—х;
```
Оба оператора инкремента и декремента могут быть как префиксным (предварять операнд), так и постфиксным (следовать за операндом). Например, оператор
```
х = х + 1;
```
можно переписать так:
```
++х; // префиксная форма
```
или так:
```
х++; // постфиксная форма
```
В приведенных выше примерах не имело особого значения, применять ли оператор инкремента в префиксной или постфиксной форме. Но когда операторы инкремента и декремента являются частью более крупного выражения, отличия между этими формами уже имеют значение. Так, если оператор инкремента или декремента предшествует операнду, то сначала выполняется соответствующее приращение, а затем получается значение операнда для последующего его использования в других элементах выражения. А если оператор инкремента или декремента следует за операндом, то сначала получается значение операнда, а затем выполняется инкремент или декремент. Рассмотрим следующие строки кода:
```
х = 10;
у = ++х;
```
После их выполнения значение переменной у будет равно 11. Но если изменить код так, как показано ниже, результат будет другим.
```
х = 10;
у = х++;
```
Теперь значение переменной у равно 10. Но в обоих случаях значение переменной х будет равно 11. Возможность контролировать момент выполнения операции инкремента или декремента дает немало преимуществ при написании программ.

### Операторы отношения и логические операторы
Операторы отношения отличаются от логических операторов тем, что первые опреде ляют отношения между значениями, а вторые связывают вместе логические значения (true или false), получаемые в результате определения отношений между значениями. Операторы отношения возвращают логическое значение true или false, и поэтому они нередко используются совместно с логическими операторами. По этой причине они и рассматриваются вместе.

Ниже перечислены операторы отношения.

| Оператор | Значение         |
|----------|------------------|
| ==       | Равно            |
| &vert;=       | Неравно          |
| >        | Больше           |
| <        | Меньше           |
| >=       | Больше или равно |
| <=       | Меньше или равно |

Далее перечислены логические операторы.

| Оператор | Значение        |
|----------|-----------------|
| &        | И               |
| &vert;        | ИЛИ             |
| ^        | Исключающее ИЛИ |
| &vert;&vert;       | Укороченное ИЛИ |
| &&       | Укороченное И   |
| !        | НЕ              |

Результатом выполнения оператора отношения или логического оператора является логическое значение типа boolean.

В Java все объекты могут быть проверены на равенство или неравенство с помощью операторов == и != соответственно. Но операторы <, >, <= и >= могут быть применены только к тем типам данных, для которых определено отношение порядка. Следовательно, все операторы отношения можно применять к данным числовых типов и типа char. А логические значения типа boolean можно проверить только на равенство или неравенство, поскольку истинные (true) и ложные (false) значения не имеют отношения порядка. Например, выражение true > false не имеет смысла в Java.

Операнды логических операторов должны иметь тип boolean, как, впрочем, и результаты выполнения этих операторов. Логические операторы &, |, А и ! выполняют логические операции И, ИЛИ, исключающее ИЛИ и НЕ в соответствии со следующей таблицей истинности.

| P     | Q     | P & Q | P &vert; Q | P ^ Q | !p    |
|-------|-------|-------|-------|-------|-------|
| false | false | false | false | false | true  |
| true  | false | false | true  | true  | false |
| false | true  | false | true  | true  | true  |
| true  | true  | true  | true  | false | false |

Как следует из приведенной выше таблицы, результатом выполнения логической операции исключающее ИЛИ будет истинное значение (true), если один и только один ее операнд имеет логическое значение true.

Приведенный ниже пример программы демонстрирует применение некоторых операторов отношения и логических операторов.
```
// Демонстрация операторов отношения и логических операторов,
class RelLogOps {
    public static void main(String args[]) {
        int i, j;
        boolean bl, b2;

        i = 10;
        j = 11;
        if(i < j) System.out.println("i < j");
        if(i <= j) System.out.println("i <= j");
        if(i != j) System.out.println("i != j");
        if(i == j) System.out.println("this won't execute");
        if(i >= j) System.out.println("this won't execute");
        if(i > j) System.out.println("this won't execute");

        bl = true;
        b2 = false;
        if(bl & b2) System.out.println("this won't  execute");
        if(! (bl    & b2)) System.out.println("! (bl &  b2) is  true");
        if(bl | b2) System.out.println("bl | b2 is true");
        if(bl A b2) System.out.println("bl A b2 is true");
    }
}
```
Результат выполнения данной программы выглядит следующим образом:
```
i < j
i <= j
i != j
! (bl & b2) is true
bl | b2 is true
bl A b2 is true
```

### Укороченные логические операторы
В Java предусмотрены также специальные, укороченные варианты логических операторов И и ИЛИ, предназначенные для получения более эффективного кода. Поясним это на следующих примерах логических операций. Если первый операнд логической операции И имеет ложное значение (false), то ее результат будет иметь ложное значение независимо от значения второго операнда. Если же первый операнд логической операции ИЛИ имеет истинное значение (true), то ее результат будет иметь истинное значение независимо от значения второго операнда. Благодаря тому что значение второго операнда в этих операциях вычислять не нужно, экономится время и повышается эффективность кода.

Укороченная логическая операция И выполняется с помощью оператора 66, а укороченная логическая операция ИЛИ — с помощью оператора | |. Этим укороченным логическим операторам соответствуют обычные логические операторы & и |. Единственное отличие укороченного логического оператора от обычного заключается в том, что второй его операнд вычисляется только по мере необходимости.

В приведенном ниже примере программы демонстрируется применение укороченного логического оператора И. В этой программе с помощью операции деления по модулю определяется следующее: делится ли значение переменной d на значение переменной нацело. Если остаток от деления n/d равен нулю, то п делится на d нацело. Но поскольку данная операция подразумевает деление, то для проверки условия деления на нуль служит укороченный логический оператор И.

```
// Демонстрация укороченных логических операторов,
class SCops {
    public static void main(String args[]) {
        int n, d, g;

        n = 10;
        d = 2;
        if(d != 0 && (n % d) == 0)
            System.out.println(d + " is a factor of " + n) ;

        d = 0; // установить нулевое значение в переменной d

        // Второй операнд не вычисляется, поскольку значение
        // переменной d равно нулю. Таким образом, укороченный
        // логический оператор предотвращает деление на нуль.
        if (d ! = 0 && (n % d) == 0) //
           System.out.println(d + " is a factor of " + n) ;

        /* А теперь те же самые действия выполняются без укороченного
           логического оператора. На этот раз вычисляются оба операнда,
           в результате чего возникает ошибка деления на нуль.
        */
        if(d != 0 & (п % d) == 0)
            System.out.println(d + " is a factor of " + n) ;
    }
}
```
Для предотвращения возможности деления на нуль в условном операторе if сначала проверяется, равно ли нулю значение переменной d. Если эта проверка дает истинный результат, вычисление второго операнда укороченного логического оператора И не выполняется. Так, если значение переменной d равно 2, вычисляется остаток от деления по модулю. Если же значение переменной d равно нулю, операция деления по модулю пропускается, а следовательно, предотвращается деление на нуль. В конце рассматриваемой здесь программы применяется обычный логический оператор И, в котором вычисляются оба операнда, а это может привести к делению на нуль при выполнении данной программы.

И последнее замечание: в формальной спецификации Java укороченный оператор И называется условным логическим оператором И, а укороченный оператор ИЛИ — условным логическим оператором ИЛИ, но чаще подобные операторы называются укороченными.

### Оператор присваивания
Оператор присваивания уже не раз применялся в примерах программ, начиная с главы 1. И теперь настало время дать ему формальное определение. Оператор присваивания обозначается одиночным знаком равенства (=). В Java он выполняет те же действия, что и в других языках программирования. Ниже приведена общая форма этого оператора.
```
переменная = выражение
```
где переменная и выражение должны иметь совместимые типы.

У оператора присваивания имеется одна интересная особенность, о которой вам будет полезно знать: он позволяет создавать цепочку операций присваивания. Рассмотрим, например, следующий фрагмент кода:
```
int х, у, z;
x=y=z=100; // присвоить значение 100 переменным х, у и z
```
В приведенном выше фрагменте кода одно и то же значение 100 задается для переменных х, у и z с помощью единственного оператора присваивания =, получающего всякий раз значение от операнда из правой части выражения. Таким образом, значение 100 присваивается сначала переменной z, затем переменной у и, наконец, переменной х. Такой способ присваивания по цепочке удобен для задания общего значения целой группе переменных.

### Укороченные операторы присваивания
В Java предусмотрены специальные укороченные операторы присваивания, упрощающие программирование некоторых операций присваивания. Обратимся сначала к простому примеру. Приведенный ниже оператор присваивания
```
х = х + 10;
```
можно переписать, используя следующий укороченный оператор присваивания:
```
х += 10;
```
Пара операторов += указывает компилятору на то, что переменной х должно быть присвоено ее первоначальное значение, увеличенное на 10.

Рассмотрим еще один пример. Оператор
```
х = х - 100;
```
и оператор
```
х -= 100;
```
выполняют одни и те же действия. Оба оператора присваивают переменной х ее первоначальное значение, уменьшенное на 100.

Для многих двоичных операций в Java, т.е. операций, требующих наличия двух операндов, существуют отдельные укороченные операторы присваивания. Общая форма всех этих операторов имеет следующий вид:
```
переменная ор = выражение
```
где ор — арифметический или логический оператор, применяемый вместе с оператором присваивания.

Ниже перечислены укороченные операторы присваивания для арифметических и логических операций.

|    |    |    |    |
|----|----|----|----|
| += | -= | *= | /= |
| %= | &= | &vert;= | ^= |

Каждый из перечисленных выше операторов состоит из двух знаков, обозначающих арифметическую или логическую операцию, а также операцию присваивания. Поэтому их часто еще называют составными операторами присваивания.

У составных операторов присваивания имеются два главных преимущества. Во-первых, они более компактны, чем их неукороченные эквиваленты. И во-вторых, дают более эффективный исполняемый код, поскольку левый операнд этих операторов вычисляется только один раз. Именно по этим причинам составные операторы присваивания чаще всего применяются в программах, профессионально написанных на Java.

## Преобразование типов при присваивании
При написании программ очень часто возникает потребность в присваивании значения, хранящегося в переменной одного типа, переменной другого типа. Например, значение int, возможно, потребуется присвоить переменной float, как показано ниже.
```
int i;
float f;

i = 10;
f = i; // присвоить значение переменной типа int переменной типа float
```
Если типы данных являются совместимыми, значение из правой части оператора присваивания автоматически преобразуется к типу данных в левой его части. Так, в приведенном выше фрагменте кода значение переменной i преобразуется в тип float, а затем присваивается переменной f. Но ведь Java — язык со строгим контролем типов, и далеко не все типы данных в нем совместимы, поэтому неявное преобразование типов выполняется не всегда. В частности, типы boolean и int не являются совместимыми.

Автоматическое преобразование типов в операции присваивания выполняется при соблюдении следующих условий:
* оба типа являются совместимыми;
* целевой тип обладает более широким диапазоном допустимых значений, чем исходный тип.

Если оба перечисленных выше условия соблюдаются, происходит расширяющее преобразование типов. Например, диапазона значений, допустимых для типа int, совершенно достаточно, чтобы представить любое значение типа byte, а кроме того, оба эти типа данных являются целочисленными. Поэтому и происходит автоматическое преобразование типа byte в тип int.

С точки зрения расширяющего преобразования типов целочисленные типы и типы с плавающей точкой совместимы друг с другом. Например, приведенная ниже программа написана корректно, поскольку преобразование типа long в тип double является расширяющим и выполняется автоматически.
```
// Демонстрация автоматического преобразования типа long в тип double,
class LtoD {
    public static void main(String args[])  {
        long L;
        double D;

        L = 100123285L;
        // Автоматическое преобразование типа long в тип double.
        D = L;

        System.out.println("L and D: " + L + " " + D);
    }
}
```
В то же время тип double не может быть автоматически преобразован в тип long, поскольку такое преобразование уже не является расширяющим. Следовательно, приведенный ниже вариант той же самом программы оказывается некорректным.
```
// *** Эта программа не подлежит компиляции. ***
class LtoD {
    public static void main(String args[]) {
        long L;
        double D;

        D = 100123285.0;

        // Тип double не преобразуется автоматически в тип long.
        L = D; // Ошибка!!!

        System.out.println("L and D: " + L + " " + D) ;
    }
}
```
Автоматическое преобразование числовых типов в тип char или boolean не производится. Кроме того, типы char и boolean несовместимы друг с другом. Тем не менее переменной char может быть присвоено значение, представленное целочисленным литералом.

## Приведение несовместимых типов

Несмотря на всю полезность неявных автоматических преобразований типов, они неспособны удовлетворить все потребности в программировании, поскольку допускают лишь расширяющие преобразования совместимых типов. А во всех остальных случаях приходится обращаться к приведению типов. Приведение — это команда компилятору преобразовать результат вычисления выражения в указанный тип. А для этого требуется явное преобразование типов. Ниже показана общая форма приведения типов.
```
(целевой_тип) выражение
```
где целевой_тип обозначает тот тип, в который желательно преобразовать указанное выражение. Так, если требуется привести значение, возвращаемое выражением х / у, к типу int, это можно сделать следующим образом:
```
double х, у;
// ...
(int) (х / у)
```
В данном случае приведение типов обеспечит преобразование результатов выполнения выражения в тип int, несмотря на то, что переменные х и у принадлежат к типу double. Выражение х / у следует непременно заключить в круглые скобки, иначе будет преобразован не результат деления, а только значение переменной х. Приведение типов в данном случае требуется потому, что автоматическое преобразование типа double в тип int не выполняется.

Если приведение типов приводит к сужающему преобразованию, то часть информации может быть потеряна. Например, в результате приведения типа long к типу int часть информации потеряется, если значение типа long окажется больше диапазона представления чисел для типа int, поскольку старшие разряды этого числового значения отбрасываются. Когда же значение с плавающей точкой приводится к целочисленному, в результате усечения теряется дробная часть этого числового значения. Так, если присвоить значение 1,23 целочисленной переменной, то в результате в ней останется лишь целая часть исходного числа (1), а дробная его часть (0,23) будет потеряна.

Ниже приведен пример программы, демонстрирующий некоторые виды преобразований, требующие явного приведения типов.
```
// Демонстрация приведения типов,
class CastDemo {
    public static void main(String args[]) {
        double x, y;
        byte b;
        int i;
        char ch;

        x = 10.0;
        У = 3.0;
        // В данном случае теряется дробная часть числа.
        i = (int) (х / у); // привести тип double к типу int
        System.out.println("Integer outcome of x / y: " + i) ;

        i = 100;
        // А в этом случае данные не теряются. Тип byte может
        // содержать значение 100.
        Ъ = (byte) i;
        System.out.println ("Value of b: " + b) ;

        i = 257;
        //На этот раз данные теряются. Тип byte не может
        // содержать значение 257.
        b = (byte) i;
        System.out.println("Value of b: " + b);

        b = 88; // Представление символа X в коде ASCII.
        //И снова требуется явное приведение несовместимых типов.
        ch = (char) b;
        System.out.println("ch: " + ch);
    }
}
```
Выполнение этой программы дает следующий результат:
```
Integer outcome of х / у: 3
Value of b: 100
Value of b: 1
ch: X
```
В данной программе приведение выражения (х / у) к типу int означает потерю дробной части числового значения результата деления. Когда переменной b присваивается значение 100 из переменной i, данные не теряются, поскольку диапазон допустимых значений у типа byte достаточен для представления этого значения. Далее при попытке присвоить переменной b значение 257 снова происходит потеря данных, поскольку значение 257 оказывается за пределами диапазона допустимых значений для типа byte. И наконец, когда переменной char присваивается содержимое переменной типа byte, данные не теряются, но явное приведение типов все же требуется.

## Предшествование операторов
В табл. 2.3 приведен порядок предшествования всех операторов в Java: от самого высокого до самого низкого. В эту таблицу включен ряд операторов, рассматриваемых далее в этой книге. Формально разделители [], () и . могут действовать как операторы, и в этом случае они будут иметь наивысший порядок предшествования.

Таблица 2.3. Предшествование операторов в Java

| Наивысший порядок |                  |    |    |                  |                   |                    |
|-------------------|------------------|----|----|------------------|-------------------|--------------------|
| ++ (постфиксный)  | -- (постфиксный) |    |    |                  |                   |                    |
| ++ (префиксный)   | -- (префиксный)  | ~  | !  | + (унарный плюс) | - (унарный минус) | (приведение типов) |
| *                 | /                | %  |    |                  |                   |                    |
| +                 | -                |    |    |                  |                   |                    |
| >>                | <<<              | << |    |                  |                   |                    |
| >                 | >=               | <  | <= | instanceof       |                   |                    |
| ==                | !=               |    |    |                  |                   |                    |
| &                 |                  |    |    |                  |                   |                    |
| ^                 |                  |    |    |                  |                   |                    |
| &vert;                 |                  |    |    |                  |                   |                    |
| &&                |                  |    |    |                  |                   |                    |
| &vert;&vert;                |                  |    |    |                  |                   |                    |
| ?:                |                  |    |    |                  |                   |                    |
| =                 | op=              |    |    |                  |                   |                    |

**Пример для опробования 2.2.**
Отображение таблицы истинности для логических операторов

В этом проекте предстоит создать программу, которая отображает таблицу истинности для логических операторов Java. Для удобства восприятия отображаемой информации следует выровнять столбцы таблицы. В данном проекте используется ряд языковых средств, рассмотренных ранее в этой главе, включая управляющие последовательности и логические операторы, а также демонстрируются отличия в предшествовании арифметических и логических операторов.

Последовательность действий
1. Создайте новый файл LogicalOpTable. java.
2. Для того чтобы обеспечить выравнивание столбцов таблицы, в каждую выводимую строку следует ввести символы \t. В качестве примера ниже приведен вызов метода println() для отображения заголовков таблицы.

    ```
    System.out.println(nP\tQ\tAND\tOR\tXOR\tNOT");
    ```

3.  Для того чтобы сведения об операторах располагались под соответствующими заголовками, в каждую последующую строку таблицы должны быть введены символы табуляции.
4.  Введите в файл LogicalOpTable . j ava исходный код программы, как показано ниже.
    ```
    // Пример для опробования 2.2.
    // Отображение таблицы истинности для логических операторов,
    class LogicalOpTable {
        public static void main(String args[])  {
            boolean p, q;

            System.out.println(MP\tQ\tAND\tOR\tXOR\tNOT");

            p = true; q = true;
            System.out.print(p + "\tM + q +"\tn);
            System.out.print((p&q) + "\t" + (plq) + "\t");
            System.out.println((pAq) + "\t" + (Ip));

            p = true; q = false;
            System.out.print(p + "\t" + q +"\t");
            System.out.print((p&q) + "\t" + (plq) + "\t");
            System.out.println((pAq) + "\t" + (!p));

            p = false; q = true;
            System, out .print (p + n\t" + q +"\t,f);
            System.out.print((p&q) + "\t" + (plq) + "\t");
            System.out.println((pAq) + M\t" + (!p));

            p = false; q = false;
            System.out.print(p + "\t" + q +"\t");
            System.out.print((p&q) + "\t" + (plq) + "\t");
            System.out.println((pAq) + "\t" + (!p));
        }
    }
    ```
    Обратите внимание на то, что в операторах с вызовами метода println() логические операторы заключены в круглые скобки. Эти скобки необходимы для соблюдения предшествования операторов. В частности, арифметический оператор + имеет более высокий порядок предшествования, чем логические операторы.
5.  Скомпилируйте программу и запустите ее на выполнение, чтобы вывести на экран следующий результат:
    ```
    P       Q       AND OR  XOR NOT
    true    true    true    true    false   false
    true    false   false   true    true    false
    false   true    false   true    true    true
    false   false   false   false   false   true
    ```
6.  Попробуйте видоизменить программу таким образом, чтобы вместо логических значений true и false отображались значения 1 и 0. Это потребует больших усилий, чем кажется на первый взгляд!

## Выражения
Операторы, переменные и литералы являются составными частями выражений. Выражением в Java может стать любое допустимое сочетание этих составных частей. Выражения должны быть уже знакомы вам по предыдущим примерам программ. Более того, вы изучали их в школьном курсе алгебры. Но некоторые их особенности все же нуждаются в обсуждении.

### Преобразование типов в выражениях типов в выражениях
В выражении можно свободно употреблять два или несколько типов данных, при условии их совместимости друг с другом. Например, в одном выражении допускается применение типов short и long, поскольку оба типа являются числовыми. Когда в выражении употребляются разные типы данных, они преобразуются в один и тот же тип по принятым в Java правилам продвижения типов.

Сначала все значения типа char, byte и short продвигаются к типу int. Затем все выражение продвигается к типу long, если хотя бы один из его операндов принадлежит к типу long. Далее все выражение продвигается к типу float, если хотя бы один из операндов относится к типу float. А если какой-нибудь из операндов относится к типу double, то результат также относится к типу double.

Очень важно иметь в виду, что правила продвижения типов применяются только к значениям, над которыми выполняются действия по мере вычисления выражения. Так, если значение переменной типа byte при вычислении выражения продвигается к типу int, за пределами выражения эта переменная будет по-прежнему относиться к типу byte. Следовательно, продвижение типов затрагивает только вычисление выражения.

Но продвижение типов может иногда привести к неожиданным результатам. Если, например, в арифметической операции используются два значения типа byte, то про исходит следующее. Сначала операнды типа byte продвигаются к типу int. А затем выполняется операция, дающая результат типа int. Следовательно, результат выполнения операции, в которой участвуют два значения типа byte, будет иметь тип int. Но ведь это не тот результат, который можно было бы с очевидностью предположить. Рассмотрим следующий пример программы:
```
// Неожиданный результат продвижения типов!
class PromDemo {
    public static void main(String args[]) {
        byte b;
        int i;

        b = 10;
        // В данном случае приведение типов не требуется, так как
        // результат вычисления выражения уже относится к типу int.
        i  = b * b;

        b = 10;
        // А в этом случае приведение типов требуется для
        // присваивания значения int переменной типа byte!
        b = (byte) (b * Ь); // cast needed!!

        System.out.println("i and b: " + i + " " + b);
    }
}
```
Как ни странно, но когда результат вычисления выражения b*b присваивается обратно переменной Ь, то возникает потребность в приведении к типу byte! Объясняется
это тем, что в выражении b*b значение переменной b продвигается к типу int и поэтому не может быть присвоено переменной типа byte без приведения типов. Имейте это обстоятельство в виду, если получите неожиданное сообщение об ошибке несовместимости типов в выражениях, которые, на первый взгляд, кажутся совершенно правильными.

Аналогичная ситуация возникает при выполнении операций с символьными операндами. Например, в следующем фрагменте кода требуется обратное приведение к типу char, поскольку операнды chi и ch2 в выражении продвигаются к типу int:
```
char chi = 'a', ch2 = ' b';
chi = (char) (chi + ch2);
```
Без приведения типов результат сложения операндов chi и ch2 будет иметь тип int, и поэтому его нельзя присвоить переменной типа char.

Приведение типов необходимо не только при присваивании значения переменной. Рассмотрим в качестве примера следующую программу. В ней приведение типов выполняется для того, чтобы дробная часть числового значения типа double не была утеряна. В противном случае операция деления будет выполняться над целыми числами.
```
// Приведение типов для правильного вычисления выражения,
class UseCast {
    public static void main(String args[])  {
        int i;
        for(i = 0; i < 5; i++) {
            System, out .println (i + " / 3: 11 + i / 3) ;
            System.out.println(i + " / 3 with fractions: "
            + (double) i / 3);
            System.out.println();
        }
    }
}
```
Ниже приведен результат выполнения данной программы.
```
0   / 3: 0
0/3 with fractions: 0.0
1   / 3: 0
1/3 with fractions: 0.3333333333333333
2   / 3: 0
2/3 with fractions: 0.6666666666666666
3/3: 1
3/3 with fractions: 1.0
4   / 3: 1
4/3 with fractions: 1.3333333333333333
```

### Пробелы и круглые скобки
Для того чтобы сделать выражения в коде Java более удобными для восприятия, в них можно использовать символы табуляции и пробелы. Например, ниже приведены два варианта одного и того же выражения, но второй вариант читается гораздо легче.
```
х=10/у*(127/х) ;
х = 10 / у * (127/х);
```
Круглые скобки повышают порядок предшествования содержащихся в них операций. (Аналогичное правило применяется и в алгебре.) Избыточные скобки допустимы. Они не приводят к ошибке и не замедляют выполнение программы. В некоторых случаях лишние скобки даже желательны. Они поясняют порядок вычисления выражения как для вас, так и для тех, кто будет разбирать исходный код вашей программы. Какое из приведенных ниже двух выражений воспринимается легче?
```
х = y/3-34*temp+127 ;
х = (у/3) - (34*temp) + 127;
```

## Упражнение для самопроверки по материалу главы 2
1. Почему в Java строго определены диапазоны допустимых значений и области действия простых типов?
2. Что собой представляет символьный тип в Java и чем он отличается от символьного типа в ряде других языков программирования?
3. Переменная типа boolean может иметь любое значение, поскольку любое ненулевое значение интерпретируется как истинное. Верно или неверно?
4. Допустим, результат выполнения программы выглядит следующим образом:
    ```
    One
    Two
    Three
    ```
    Напишите строку кода с вызовом метода println(), где этот результат выводится в одной символьной строке.
5.  Какая ошибка допущена в следующем фрагменте кода:
    ```
    for(i = 0; i < 10; i++) {
        int sum;
        sum = sum + i;
    }
    System.out.println("Sum is: " + sum);
    ```
6.  Поясните отличие между префиксной и постфиксной формами оператора инкремента.
7.  Покажите, каким образом укороченный логический оператор И может предотвратить деление на нуль.
8.  К какому типу продвигаются типы byte и short при вычислении выражения?
9.  Когда возникает потребность в явном приведении типов?
10. Напишите программу, которая находила бы простые числа в пределах от 2 до 100.
11. Оказывают ли лишние скобки влияние на эффективность выполнения программ?
12. Определяет ли кодовый блок область действия переменных?